<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dev Note</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://note.49px.com/"/>
  <updated>2019-04-30T08:05:44.000Z</updated>
  <id>http://note.49px.com/</id>
  
  <author>
    <name>Yang Le</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习</title>
    <link href="http://note.49px.com/deep-learning/"/>
    <id>http://note.49px.com/deep-learning/</id>
    <published>2018-05-11T16:00:00.000Z</published>
    <updated>2019-04-30T08:05:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="超参数调整"><a href="#超参数调整" class="headerlink" title="超参数调整"></a>超参数调整</h4><h5 id="training-dev-test集"><a href="#training-dev-test集" class="headerlink" title="training/dev/test集"></a>training/dev/test集</h5><p>dev集就是validation集，用于评估超参数选择的好坏。test集只在训练完成后做一次评估。要确保dev/test集的数据来自同一分布。如果来自实际应用的数据太少，优先划分到dev/test集。</p><h6 id="bias和variance"><a href="#bias和variance" class="headerlink" title="bias和variance"></a>bias和variance</h6><p>high bias对应欠拟合，high variance对应过拟合</p><ul><li>若training集误差比人类误差（比如0）高得多，说明high bias、欠拟合。</li><li>若dev集误差比training集误差高得多，说明high variance、过拟合。</li><li>若test集误差比dev集误差高得多，说明dev集过拟合，需要扩充dev集。</li></ul><h6 id="training集的数据可来自不同分布"><a href="#training集的数据可来自不同分布" class="headerlink" title="training集的数据可来自不同分布"></a>training集的数据可来自不同分布</h6><p>如果training集的数据来自不同分布，就要从training集随机取些数据构成training-dev集。training-dev集与training集来自同一分布，但不参与训练，部分取代原先dev集的功能。</p><ul><li>若training-dev集误差比training集误差高得多，说明high variance、过拟合。</li><li>若training-dev集误差和training集误差差不多，但dev集误差比training-dev集误差高得多，说明数据不匹配。这时要多制造或者采集符合dev/test集特征的training集数据。</li></ul><h5 id="防止过拟合"><a href="#防止过拟合" class="headerlink" title="防止过拟合"></a>防止过拟合</h5><p>regularization（正则化）：在代价函数J(w,b)中给权重矩阵w添加惩罚。一般用L2正则 $||w||_2^2 = \sum w_j^2$，效果是参数值减小。</p><blockquote><p>L1正则 $|w|_1 = \sum |w_j|$ 效果是参数值为0。因为|w|图像关于y轴对称，在x=0处取极小值。</p></blockquote><p>dropout（随机失活）：每次前向-后向传播中，各层随机保留keep-prob比例的单元，并将单元输出/=keep-prob以弥补关掉单元的输出。各层的keep-prob参数可以不同。</p><p>data augmentation（数据扩展）：比如把图片翻转、旋转、切变、裁切、变色等。</p><h5 id="输入归一化（normalize）"><a href="#输入归一化（normalize）" class="headerlink" title="输入归一化（normalize）"></a>输入归一化（normalize）</h5><p>$x = (x-μ)/σ$，均值归0、方差归1</p><h5 id="梯度爆炸或消失"><a href="#梯度爆炸或消失" class="headerlink" title="梯度爆炸或消失"></a>梯度爆炸或消失</h5><p>梯度爆炸只需clipping掉太大的梯度。</p><p>梯度消失可从一些方面缓解，比如激活函数、权重矩阵初始化、跨层连接</p><ul><li>将激活函数从tanh/sigmoid换成relu，因为relu当x&gt;0时梯度为1，乘上不会减小。</li><li>将权重矩阵初始化为单位矩阵I。更常用Xavier初始化，使输入输出方差相同：$rand()\sqrt{ \frac{1}{n_{in}} }$，$n_{in}$是该层输入单元的个数；若激活函数是relu，有一半情况不激活：$rand()\sqrt{ \frac{2}{n_{in}} }$。</li><li>ResNet中跨层连接；RNN中使用GRU或LSTM等门单元。</li></ul><h5 id="mini-batch"><a href="#mini-batch" class="headerlink" title="mini-batch"></a>mini-batch</h5><p>每次只取m个样本，在这mini-batch上梯度下降。m大时算得快，因为mini-batch整体向量化参与计算。经验上最好m&lt;=32，小mini-batch训练出的模型泛化能力更强。<br>特例：m=1，叫作stochastic梯度下降；m=总样本数，叫作batch梯度下降。</p><h5 id="梯度下降的加速"><a href="#梯度下降的加速" class="headerlink" title="梯度下降的加速"></a>梯度下降的加速</h5><p>高维空间容易遇到”鞍点”减慢下降速度，下面算法都能解决鞍点问题。</p><p>常用的Adam算法整合了Momentum和RMSprop</p><h6 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h6><p>指数加权移动平均：$v_t = βv_{t-1} + (1-β)*θ_t$。可修正初始偏差 $v_t / (1-β^t)$</p><p>用梯度的移动平均更新权重：<br>$V_{dW} = βV_{dW} + (1-β)dW$，$W=W-αV_{dW}$。b同理更新。</p><h6 id="RMSprop（root-mean-square-prop）"><a href="#RMSprop（root-mean-square-prop）" class="headerlink" title="RMSprop（root mean square prop）"></a>RMSprop（root mean square prop）</h6><p>$S_{dW}=βS_{dW} + (1-β)dW^2（dW^2按元素乘$），$W=W-α\frac{dW}{\sqrt{S_{dW}}}$。<br>因为$dW$值较小，$S_{dW}$较小，$\frac{dW}{\sqrt{S_{dW}}}$较大，W移动变快，W方向收敛加快。</p><p>b同理更新，b移动变慢，b方向振荡减小。</p><h5 id="学习率衰减（learning-rate-decay）"><a href="#学习率衰减（learning-rate-decay）" class="headerlink" title="学习率衰减（learning rate decay）"></a>学习率衰减（learning rate decay）</h5><p>跑一遍数据叫<em>1 epoch</em>，随着epoch增加，减小学习率。</p><h4 id="提前停止"><a href="#提前停止" class="headerlink" title="提前停止"></a>提前停止</h4><p>一般不用这方法，因为它同时有两种不正交的影响：提高了dev集拟合、降低train集拟合。</p><h5 id="Batch-Norm"><a href="#Batch-Norm" class="headerlink" title="Batch Norm"></a>Batch Norm</h5><p>隐藏层在应用激活函数a=g(z)前，先对该层z值进行归一化，使它们有相同的均值（不一定是0）和方差（不一定是1）。</p><p>新添BN层，输入z值计算均值μ和方差σ，$z_{norm}^{(i)} = \frac{z^{(i)} - μ}{\sqrt{σ^2 + ε}}$，$\tilde{z}^{(i)} = γz_{norm}^{(i)} + β$。其中γ和β是待学习的参数，输出值$\tilde{z}^{(i)}$代替$z^{(i)}$进激活函数层。</p><p>使用BN时 $z^{[l]} = W^{[l]}a^{[l-1]} + b^{[l]}$ 中的$b^{[l]}$项可省略，不省略也将被归一化减掉。</p><p>训练时在一个个mini-batch上应用BN，更新μ和σ的移动平均；测试时用μ和σ的移动平均作总体μ和σ的估算。</p><h5 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h5><p>为利用大数据量任务A训练好的深度网络N，相同类型的小数据量任务B换掉N的最后几层换上新层，然后在最后一些层上更新权重（其余层不更新权重）。</p><p>如果更新所有层的权重，那么原先A上的训练叫做pre-training，现在B上的训练叫做fine-tuning。 </p><hr><h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h3><h4 id="物体分类和定位一起做"><a href="#物体分类和定位一起做" class="headerlink" title="物体分类和定位一起做"></a>物体分类和定位一起做</h4><p>图片中单物体定位：输出标签 anchorBox [ 图片是否包含物体?，若包含时物体定位框的四个点，物体的各个分类]。</p><p>滑动窗口算法：一小块一小块窗口卷积地看图片是否包含物体。<br>全卷积网络优化：把Convs-FullyConnected的网络改成Convs-1x1Convs的全卷积网络，然后在整个图片上卷积，一下子算出了各块窗口的卷积。</p><p>YOLO算法（You Only Look Once）：把图片分成一些不重叠网格，每个网格对应输出中的一维anchorBox。物体中心在哪个网格则物体在哪个网格，每个网格识别中心落在该网格的物体。同样用全卷积网络，一下子算出各网格的卷积。</p><p>去掉多余定位框：两个矩形框的重叠率用IoU（Intersection over Union）表示。在物体定位时会找到大大小小多个定位框，首先去掉识别概率 &lt; threshold的框；然后先选个概率最高的框k，去掉与k的重叠率较高的框（non-max supression，非极大值抑制），如此继续。</p><p>一个网格识别多个物体：各种形状矩形定义一个anchorBox，扩展输出标签 [anchorBox1, anchorBox2, anchorBox3…]</p><p>另：多物体的分类和定位，region-based CNN，先用分割算法找出些候选色块，再分类。</p><h4 id="人脸识别：要训练相似度函数"><a href="#人脸识别：要训练相似度函数" class="headerlink" title="人脸识别：要训练相似度函数"></a>人脸识别：要训练相似度函数</h4><p>Siamese网络是共享权值的两个相同网络Conv-Pool-FC，两个输出连到最后一层，训练的相似度函数。要使相同人脸的向量距离小、不同人脸的向量距离大。训练网络时是需要有同一人的多张人脸。<br>可以：每次同时输入三张图片，一张基准Anchor、一张相同人的Positive、一张不同人的Negative，要求$d(A, P) + α &lt;= d(A, N)，α&gt;0$。$L = max( d(A, P) - d(A, N) + α, 0 )$，α限制要显著地小。<br>或者：每次同时输入两张图片，最后做相不相似的二元分类。$y = σ( \sum( w * | f^{(i)}_k - f^{(j)}_k | ) + b )$</p><h4 id="神经风格转换：给Content图片C加上Style图片S的风格"><a href="#神经风格转换：给Content图片C加上Style图片S的风格" class="headerlink" title="神经风格转换：给Content图片C加上Style图片S的风格"></a>神经风格转换：给Content图片C加上Style图片S的风格</h4><p>先随机生成图片G，然后最小化代价函数，根据梯度调整G。代价函数由内容和风格两部分构成，$J(G) = αJ_{content}(C, G) + βJ_{style}(S, G)$。<br>内容代价是在隐藏层L上计算与内容图片激活情况的差距，$J_{content}(C,G) = 1/2 * || a^{C} - a^{G} ||<em>2^2$。<br>风格是隐藏层L（<code>w*h*c</code>）的c个子层间的“相关性”。因为一个子层是一种卷积核运算的结果，表示提取了某种特性。两子层间的相关性表示两种特征同时出现的情况，各子层间的相关性表示各种特征同时出现的情况，就表示了某种风格。风格矩阵（Gram矩阵）：维度<code>c*c</code>的矩阵，每个元素表示两个子层相同位置激活值相乘的的卷积值，是一种非标准的”相关性”。风格代价是在隐藏层L上计算和风格图片的Gram矩阵的差距，$J</em>{style}(S, G) = 1/(2hwc)^2 || Gram^{S} - Gram^{G} ||_2^2$。<br>最后，不仅考虑某隐藏层L，所有层都可以加入到损失函数计算中，这就考虑了各层风格。</p><hr><h3 id="序列模型"><a href="#序列模型" class="headerlink" title="序列模型"></a>序列模型</h3><h4 id="RNN（循环神经网络）"><a href="#RNN（循环神经网络）" class="headerlink" title="RNN（循环神经网络）"></a>RNN（循环神经网络）</h4><p>t时刻输入$x_t$，t-1时刻激活值$a_{<t-1>}$参与当前激活值计算 $a_{<t>} = g( w_{aa}a^{<t-1>} + w_{ax}x^{<t>} + b_{a} )$，当前预测值 $y^{<t>} = g( w_{ya}a^{<t>} + b_{y} )$。计算激活值时的g通常选tanh、偶尔relu，计算预测值时的g根据分类问题二元sigmod、多元softmax。<br>$[A,B]$表示两矩阵横向拼接、$[A;B]$表示两矩阵竖向拼接，让$w_{a} = [w_{ax}, w{ax}]$，$a_{<t>} = g( w_{a} [a^{<t-1>}; x^{<t>}] + b_{a} )$</p><h5 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h5><p>有个词表，单词用词表长one-hot向量表示。每次输入一个单词，输出此刻各个单词的概率。最小化代价是各时刻猜测概率与实际出现单词的交叉熵。</p><p>RNN按时间一层层展开，就是一层层深度，梯度会消失。梯度消失导致无法长期依赖，可使用门单元组件解决，如GRU、LSTM等。</p><h4 id="GRU（Gate-Recurrent-Unit，门控循环单元）"><a href="#GRU（Gate-Recurrent-Unit，门控循环单元）" class="headerlink" title="GRU（Gate Recurrent Unit，门控循环单元）"></a>GRU（Gate Recurrent Unit，门控循环单元）</h4><p>记忆细胞$c^{<t>}=a^{<t>}$记录t时刻的激活值，<br>按RNN激活值计算作为候选$z^{<t>} = w_c [ c^{<t-1>};  x^{<t>} ] + b_c$，$c’^{<t>}=tanh( z^{<t>} )$，<br>一个门（简化版）控制取候选$c’^{<t>}$还是取前一值$c^{<t-1>}$，$G_u=σ( 形似z^{<t>} )$，形似$z^{<t>}$有自己的w、b参数<br>$c^{<t>} = G_u * c’^{<t>} + (1-G_u) * c^{<t-1>}$。</p><p>因为$G_{u}$通常接近于0，$c^{<t>}=c^{<t-1>}$，保持旧状态，没有梯度消失问题</p><h4 id="LSTM（Long-Short-Term-Memory，长短期记忆）"><a href="#LSTM（Long-Short-Term-Memory，长短期记忆）" class="headerlink" title="LSTM（Long Short Term Memory，长短期记忆）"></a>LSTM（Long Short Term Memory，长短期记忆）</h4><p>三个门，更新门$G_u$、忘记门$G_f$、输出门$G_o$<br>$z^{<t>} = w_c [ a^{<t-1>}; x^{<t>} ] + b_c$， $c’^{<t>}=tanh( z^{<t>} )$，<br>$G_u = σ( 形似z^{<t>} )$, $G_o = σ(  形似z^{<t>} )$, $G_o = σ( 形似z^{<t>} )$，形似$z^{<t>}$有自己的w、b参数<br>$c^{<t>} = G_u * c’^{<t>} + G_f * c^{<t-1>}$，$a^{<t>} = G_o * c^{<t>}$</p><h4 id="词嵌入学习"><a href="#词嵌入学习" class="headerlink" title="词嵌入学习"></a>词嵌入学习</h4><p>用“词嵌入”表示单词，词嵌入向量表示单词与各种语义的关联度。</p><p>skip-grams：学习映射关系 context词=&gt;附近某target词<br>负采样：选一个 context词=&gt;附近某target词 作为正样本，再取一些到随机词的映射作为负样本，训练分辨映射是从附近词中选的还是随机选的<br>glove：统计target词在content词周围出现的次数，最小化它特定的代价函数</p><h5 id="情感分类"><a href="#情感分类" class="headerlink" title="情感分类"></a>情感分类</h5><p>词嵌入作输入，经过多对一RNN，再多元分类</p><h4 id="seq2seq模型（序列到序列）"><a href="#seq2seq模型（序列到序列）" class="headerlink" title="seq2seq模型（序列到序列）"></a>seq2seq模型（序列到序列）</h4><p>一个encoder网络，接一个decoder网络</p><p>beam search（定向搜索）一次搜索k个最可能结果，是扩大搜索范围的贪婪搜索<br>要翻译句子，首先输入句子到encoder网络，decoder网络t=0时刻输出各单词概率，beam search选其中概率最高的k个进入t=1时刻。t=1时刻在试着选定第一个词的情况下算第二个词的概率，再选其中概率最高的k个。如此继续。</p><h5 id="注意力模型"><a href="#注意力模型" class="headerlink" title="注意力模型"></a>注意力模型</h5><p>为解决先编码再解码的中间向量瓶颈，引入注意力模型。</p><p>在decoder的某时刻t，对encoder各时刻t’的输出值$a^{&lt;t’&gt;}$的注意力分布$a^{&lt;t,t’&gt;}$，加权和$\sum( a^{&lt;t,t’&gt;}a^{&lt;t’&gt;} )$作为decoder时刻t的输入。</p><p>注意力分布$a^{&lt;t,t’&gt;}$由decoder时刻t-1的输出、encoder时刻t’的输出$a^{&lt;t’&gt;}$之间算相关度评分，再maxsoft归一化而得。相关度评分比如可以算两者的向量cos距离，或再引入个额外神经网络计算。</p><p>详细解释<a href="https://www.zhihu.com/question/68482809/answer/264632289" target="_blank" rel="noopener">参见</a></p><h5 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h5><p>音频预处理成时频谱spectrogram：横坐标时间、纵坐标频率、颜色亮度表示能量强度。</p><blockquote><p>频谱spectrum：时频谱中垂直于横坐标的截面，横坐标是频率、纵坐标是能量强度。</p></blockquote><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://mooc.study.163.com/university/deeplearning_ai" target="_blank" rel="noopener">DeepLearning.ai</a>  by Andrew Ng</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;超参数调整&quot;&gt;&lt;a href=&quot;#超参数调整&quot; class=&quot;headerlink&quot; title=&quot;超参数调整&quot;&gt;&lt;/a&gt;超参数调整&lt;/h4&gt;&lt;h5 id=&quot;training-dev-test集&quot;&gt;&lt;a href=&quot;#training-dev-test集&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CS224n：自然语言处理与深度学习</title>
    <link href="http://note.49px.com/nlp/"/>
    <id>http://note.49px.com/nlp/</id>
    <published>2017-10-27T16:00:00.000Z</published>
    <updated>2020-01-08T02:12:08.908Z</updated>
    
    <content type="html"><![CDATA[<h4 id="词向量"><a href="#词向量" class="headerlink" title="词向量"></a>词向量</h4><p>词的分布假说：词的特征由其上下文决定。<br><img src="/media/cs224n-word-context.png" alt=""><br>词向量又称词嵌入（word embedding），把词映射到某几个特征构成的低维向量。<em>embedding</em>在数学上表示一个映射，该映射是单射的（每个Y只有唯一的X对应，反之亦然）、结构保存的（比如在X所属空间上X1&lt;X2，那么映射后在Y所属空间上同样Y1&lt;Y2）。</p><p>工具word2vec可训练词向量。skip-gram从中心词预测周围词，CBOW从周围词预测中心词。<br><img src="/media/cs224n-word2vec-main-idea.png" alt=""></p><h5 id="skip-gram"><a href="#skip-gram" class="headerlink" title="skip-gram"></a>skip-gram</h5><p>对每个单词，计算与前后各m个邻近词共同出现的概率积J’(θ)。loss函数用负对数似然估计J(θ)。<br><img src="/media/cs224n-skipgram-detail-1.png" alt=""><br>与邻近词$u_o$共同出现的概率$p(o|c)$用softmax表示，其中$u_o^Tv_c$是邻近词$u_o$与中心词$v_c$的相似度。<br><img src="/media/cs224n-skipgram-detail-2.png" alt=""><br><a href="http://web.stanford.edu/class/cs224n/lectures/" target="_blank" rel="noopener">Lecture2课件</a>有梯度$\frac{\partial{J(θ)}}{\partial{v_c}}$的推导过程。</p><p><a href="https://www.youtube.com/watch?v=2DYxT4OMAmw&index=10&list=PL3FW7Lu3i5Jsnh1rnUwq_TcylNr7EkRe6" target="_blank" rel="noopener">Midterm Review</a>有skip-gram例子讲清楚过程。<br><img src="/media/cs224n-skipgram-process.png" alt=""></p><h5 id="cbow"><a href="#cbow" class="headerlink" title="cbow"></a>cbow</h5><p><img src="/media/cs224n-cbow-process.png" alt=""></p><h5 id="glove"><a href="#glove" class="headerlink" title="glove"></a>glove</h5><p>skip-gram用梯度下降法逐步计算了单词之间共同出现的概率。还可以用个全局矩阵记录单词之间在一定窗口内共同出现的次数，GloVe利用了这一信息。<br><img src="/media/cs224n-glove-process.png" alt=""></p><h5 id="词窗口分类"><a href="#词窗口分类" class="headerlink" title="词窗口分类"></a>词窗口分类</h5><p>利用前后各m个邻近词，把中心词在几个歧义中的分类。</p><hr><h4 id="RNN是基础构件"><a href="#RNN是基础构件" class="headerlink" title="RNN是基础构件"></a>RNN是基础构件</h4><p>RNN有一个内部状态$h_{t-1}$、待训练参数$W=\begin{bmatrix} W^{(hh)} &amp; W^{(hx)}\end{bmatrix}$，每次读取输入$x_t$，更新$z_t=W^{(hh)}h_{t-1}+W^{(hx)}x_t=\begin{bmatrix} W^{(hh)} &amp; W^{(hx)}\end{bmatrix} \begin{pmatrix}h_{t-1} \cr x_t\end{pmatrix}, h_t=g(z_t)$。</p><p>RNN网络深度较大，因链式求导不断相乘，有梯度消失或爆炸的问题。GRU和LSTM缓解了梯度消失问题，是常用的RNN。</p><h5 id="GRU-Gated-Recurrent-Unit"><a href="#GRU-Gated-Recurrent-Unit" class="headerlink" title="GRU, Gated Recurrent Unit"></a>GRU, Gated Recurrent Unit</h5><p>$h_t=gru(x_t, h_{t-1})$<br>$\tilde{h}_t$是候选更新，update gate $z_t$决定新状态中旧状态和候选更新所占比例，reset gate $r_t$决定候选更新中保留多少旧状态。<br><img src="/media/cs224n-gru-intuition-1.png" alt="">)<img src="/media/cs244n-gru-intuition-2.png" alt=""></p><h5 id="LSTM-Long-Short-Term-Memory"><a href="#LSTM-Long-Short-Term-Memory" class="headerlink" title="LSTM, Long Short Term Memory"></a>LSTM, Long Short Term Memory</h5><p>$h_t=lstm(x_t, h_{t-1})$<br><img src="/media/cs224n-lstm-1.png" alt="">)<img src="/media/cs224n-lstm-2.png" alt=""></p><h4 id="神经机器翻译"><a href="#神经机器翻译" class="headerlink" title="神经机器翻译"></a>神经机器翻译</h4><p>语言模型计算整个单词序列的概率$P(w_1,…,w_r)$。</p><p>由两个RNN分别作encoder（蓝色）和decoder（红色）。由于只记住encoder最后状态Y，翻译长句子时效果不好。<br><img src="/media/cs224n-rnn-language-model.png" alt=""><br>Attention的想法是多记住一些源状态。<br><img src="/media/cs224n-attention-mechanism-1.png" alt=""><br>decoder算$h_t$时，先算$h_{t-1}$与各源状态的相似性得分，用softmax将得分转成概率（这概率就叫attention），再加权相加各源状态得到上下文向量$c_t$，用$c_t$计算$h_t$。<br><img src="/media/cs224n-attention-mechanism-2.png" alt=""></p><h4 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h4><p>词向量拼接成长向量，长为h词的滑动filter作卷积算$c_i$<br><img src="/media/cs224n-cnn-in-nlp.png" alt=""><br><img src="/media/cs224n-cnn-vs-rnn.png" alt=""></p><h4 id="TreeRNN-Tree-Recursive-Neural-Network"><a href="#TreeRNN-Tree-Recursive-Neural-Network" class="headerlink" title="TreeRNN, Tree Recursive Neural Network"></a>TreeRNN, Tree Recursive Neural Network</h4><p><img src="/media/cs224n-recursive-vs-recurrent.png" alt=""><br>结构预测：将相邻两节点用神经网络算合并分数，取得分最高的合并出新节点。<br><img src="/media/cs224n-recursive-nn-structure-prediction.png" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.youtube.com/playlist?list=PL3FW7Lu3i5Jsnh1rnUwq_TcylNr7EkRe6" target="_blank" rel="noopener">CS224n: Natural Language Processing with Deep Learning</a> Winter 2017</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;词向量&quot;&gt;&lt;a href=&quot;#词向量&quot; class=&quot;headerlink&quot; title=&quot;词向量&quot;&gt;&lt;/a&gt;词向量&lt;/h4&gt;&lt;p&gt;词的分布假说：词的特征由其上下文决定。&lt;br&gt;&lt;img src=&quot;/media/cs224n-word-context.png&quot; a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CS231n：卷积神经网络</title>
    <link href="http://note.49px.com/cnn/"/>
    <id>http://note.49px.com/cnn/</id>
    <published>2017-10-24T16:00:00.000Z</published>
    <updated>2020-01-08T02:12:08.987Z</updated>
    
    <content type="html"><![CDATA[<h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p>后向传播其实就是使用导数的链式法则<br><img src="/media/cs231n-backprop-example1.png" alt="">)<img src="/media/cs231n-backprop-example2.png" alt=""><br>计算图节点可以按不同粒度组合<br><img src="/media/cs231n-backprop-sigmoid-gate.png" alt=""></p><h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><p>过程：用filter卷积算得新图层，多个filters算得的图层叠成新图（卷积层），新图经ReLU处理；连续Conv+ReLU弄几层，偶有Pool层降分辨率；最后把输出展成一维向量，接入全连接层（神经网络）做多元分类。</p><p>卷积层：<br><img src="/media/cs231n-conv-layer-1.png" alt="">)<img src="/media/cs231n-conv-layer-2.png" alt="">)<img src="/media/cs231n-conv-layer-3.png" alt="">)<img src="/media/cs231n-conv-layer-4.png" alt="">)<img src="/media/cs231n-conv-layer-5.png" alt=""><br>连续Conv+ReLU弄几层：<br><img src="/media/cs231n-conv-net.png" alt=""><br>偶有Pool层降分辨率：<br><img src="/media/cs231n-pool-layer.png" alt=""><br>抽样方法比如：<br><img src="/media/cs231n-pool-layer-max-sampling.png" alt=""><br>最后把输出展成一维向量，接入全连接层：<br><img src="/media/cs231n-full-connected-layer.png" alt=""></p><p>典型的架构像这样：<br><code>[(Conv-ReLU)*N-POOL?]*M-(FC-ReLU)*K-SoftMax</code></p><h4 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h4><p>各时刻共享权重参数W，由前一刻状态$h_{t-1}$、当前输入$x_t$计算新状态$h_t$、计算预测值$y_t$、计算$loss_t$；序列x全读完了总loss就是$\sum loss_t$，再后向传播计算梯度（backprop through time）、更新W。<br><img src="/media/cs231n-recurrent-neural-network.png" alt="">)<img src="/media/cs231n-rnn-computational-graph.png" alt=""><br><img src="/media/6.s191-backprop-through-time.png" alt=""></p><p>实践中，简单RNN难以描述长期依赖。更常用LSTM（Long Short Term Memory）、GRU（Gated Recurrent Unit），GRU比LSTM计算更少、效果相当。</p><hr><h4 id="多分类的loss函数"><a href="#多分类的loss函数" class="headerlink" title="多分类的loss函数"></a>多分类的loss函数</h4><h5 id="max-margin"><a href="#max-margin" class="headerlink" title="max margin"></a>max margin</h5><p>要让正确分类$s_{y_i}$比错误分类$s_j$的分数大（具体大多少无所谓，这里取大1）。满足这条件时loss为0、不满足时loss为$s_j-s_{y_i}+1$。<br><img src="/media/cs231n-multiclass-svm-loss.png" alt=""></p><h5 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h5><p><img src="/media/cs231n-softmax-classifier.png" alt=""></p><h4 id="常见激活函数"><a href="#常见激活函数" class="headerlink" title="常见激活函数"></a>常见激活函数</h4><p><img src="/media/cs231n-activation-funcs.png" alt="">)<img src="/media/cs231n-activation-funcs-tldr.png" alt=""><br>sigmoid的导数在[0, 0.25]，tanh的导数在[0, 1]<br><img src="/media/cs231n-activation-func-sigmoid.png" alt="">)<img src="/media/cs231n-activation-func-tanh.png" alt=""><br>ReLu当学习率大时梯度减得多，容易x&lt;0变为dead。可减小学习率，或者使用Leaky ReLu、ELU。<br><img src="/media/cs231n-activation-func-relu.png" alt="">)<img src="/media/cs231n-activation-func-leaky-relu.png" alt="">)<img src="/media/cs231n-activation-func-elu.png" alt="">)<img src="/media/cs231n-activation-func-maxout.png" alt=""></p><h4 id="一些调优问题"><a href="#一些调优问题" class="headerlink" title="一些调优问题"></a>一些调优问题</h4><h5 id="train-validation-test"><a href="#train-validation-test" class="headerlink" title="train/validation/test"></a>train/validation/test</h5><p>train集用于超参数选定后的模型训练，validation集用于验证超参数效果，test集只在最后出结果时用一次。交叉验证只在小数据集时有用。<br><img src="/media/cs231n-setting-hyperparameters.png" alt=""></p><h5 id="初始化权重矩阵W"><a href="#初始化权重矩阵W" class="headerlink" title="初始化权重矩阵W"></a>初始化权重矩阵W</h5><p>初始随机值太小或太大都不好。比如tanh作激活函数，若初始值太小，几次迭代后输出0。若初始值太大，函数饱和梯度=0。</p><p>可用Xavier初始法，<code>W = np.random.randn(fan_in, fan_out) / np.sqrt(fan_in)</code>。</p><p>若ReLU作激活函数，可用<code>W = np.random.randn(fan_in, fan_out) / np.sqrt(fan_in/2)</code>。</p><h5 id="Batch-Norm"><a href="#Batch-Norm" class="headerlink" title="Batch Norm"></a>Batch Norm</h5><p>训练时使用mini-batch的μ和σ修正数据：先让μ归0、σ归1，再加个BN层训练正态分布的缩放γ和平移β；测试时使用全部mini-batch上的移动平均μ和移动平均σ修正数据。<br><img src="/media/cs231n-batch-normalization-1.png" alt="">)<img src="/media/cs231n-batch-normalization-2.png" alt="">)<img src="/media/cs231n-batch-normalization-3.png" alt=""></p><h5 id="随机梯度下降陷入局部极小值或鞍点"><a href="#随机梯度下降陷入局部极小值或鞍点" class="headerlink" title="随机梯度下降陷入局部极小值或鞍点"></a>随机梯度下降陷入局部极小值或鞍点</h5><p>使用”Momentum”——移动平均梯度<br><img src="/media/cs231n-optimization-sgd-momentum.png" alt=""><br>更常用Adam优化 = Momentum + AdaGrad/RMSprop<br><img src="/media/cs231n-optimization-adam.png" alt=""></p><h5 id="dropout正则化"><a href="#dropout正则化" class="headerlink" title="dropout正则化"></a>dropout正则化</h5><p>随机关闭每层一定比例的节点，强制丢掉一些信息防止过拟合。<br><img src="/media/cs231n-regularization-dropout.png" alt=""><br><img src="/media/cs231n-optimization-inverted-dropout.png" alt=""></p><h5 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h5><p>迁移到小数据集时，重训最后一层。迁移到较大数据集时，重训最后几层。<br><img src="/media/cs231n-transfer-learning-1.png" alt="">)<img src="/media/cs231n-transfer-learning-2.png" alt=""></p><hr><p><img src="/media/cs231n-other-computer-vision-tasks.png" alt=""></p><h4 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h4><p>全卷积层，先downsampling再upsampling<br><img src="/media/cs231n-semantic-segmentation.png" alt=""><br><img src="/media/6.s094-semantic-segmentation.png" alt=""></p><h5 id="转置卷积：一种upsampling方法"><a href="#转置卷积：一种upsampling方法" class="headerlink" title="转置卷积：一种upsampling方法"></a>转置卷积：一种upsampling方法</h5><p>待upsampling的像素值、乘上filter、累加到输出的对应位置。<br><img src="/media/cs231n-transpose-convolution.png" alt=""><br>从矩阵乘法角度看<br><img src="/media/cs231n-convolution-as-matrix-multiplication-1.png" alt="">)<img src="/media/cs231n-convolution-as-matrix-multiplication-2.png" alt=""></p><h4 id="单个物体同时分类和定位"><a href="#单个物体同时分类和定位" class="headerlink" title="单个物体同时分类和定位"></a>单个物体同时分类和定位</h4><p>定位就是训练固定个数的定位参数，当作回归问题。如下面猫框有4个参数、姿势的关节位置有14个参数。<br><img src="/media/cs231n-classification-and-localization.png" alt=""><br><img src="/media/cs231n-human-pose-estimation.png" alt=""></p><h4 id="多个物体的分类和定位"><a href="#多个物体的分类和定位" class="headerlink" title="多个物体的分类和定位"></a>多个物体的分类和定位</h4><p>R-CNN（Region-based CNN）：要先用语义分割找出一些候选区域，再看这些区域是否包含关注列表中的物体并定位。<br><img src="/media/6.s094-fast-r-cnn.png" alt=""></p><h4 id="图片变成特定风格"><a href="#图片变成特定风格" class="headerlink" title="图片变成特定风格"></a>图片变成特定风格</h4><p>内容相似：使生成图的各层激活情况尽量匹配原图。<br>风格相似：使生成图的各层gram矩阵尽量匹配原图各层。<br><img src="/media/cs231n-neural-texture-synthesis-1.png" alt=""><br><img src="/media/cs231n-neural-texture-synthesis-2.png" alt=""></p><hr><h3 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h3><p><img src="/media/cs231n-unsupervised-learning.png" alt=""></p><h4 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h4><p>生成符合训练集样本分布的新数据<br><img src="/media/cs231n-generative-models-1.png" alt="">)<img src="/media/cs231n-generative-models-2.png" alt=""></p><h5 id="变分自编码器（Variational-AutoEncoder）"><a href="#变分自编码器（Variational-AutoEncoder）" class="headerlink" title="变分自编码器（Variational AutoEncoder）"></a>变分自编码器（Variational AutoEncoder）</h5><p>参见<a href="http://kvfrans.com/variational-autoencoders-explained/" target="_blank" rel="noopener">Kevin Frans</a>的解释，VAE就是给AutoEncoder里连接encoder和decoder中间的那个潜在变量添加限制，限制它符合单位正态分布。实现上训练出μ和σ，再从它们抽样出正态分布的潜在变量，就是下面的z。损失函数由两部分组成：潜在变量和单位正态分布的拟合度（KL散度），生成图像与输入图像的拟合度（均方误差）。<br><img src="/media/cs231n-variational-autoencoder.png" alt=""></p><h5 id="生成对抗网络（Generative-Adversarial-Network）"><a href="#生成对抗网络（Generative-Adversarial-Network）" class="headerlink" title="生成对抗网络（Generative Adversarial Network）"></a>生成对抗网络（Generative Adversarial Network）</h5><p>对抗博弈，generator生成假图片，discriminator区分真假图片。<br><img src="/media/cs231n-training-gans-1.png" alt="">)<img src="/media/cs231n-training-gans-2.png" alt=""></p><hr><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><p>跟环境互动，最大化奖励。数学形式就是Markov决策过程。<br><img src="/media/cs231n-reinforcement-learning.png" alt=""></p><h5 id="Q-learning"><a href="#Q-learning" class="headerlink" title="Q-learning"></a>Q-learning</h5><p><img src="/media/6.s091-q-learnig.png" alt=""><br>使用神经网络拟合Q函数，因为Q-Learning表格维度巨大难以实用。<br><img src="/media/6.s191-deep-q-network.png" alt=""></p><h5 id="Policy-Gradient"><a href="#Policy-Gradient" class="headerlink" title="Policy Gradient"></a>Policy Gradient</h5><p><img src="/media/6.s191-policy-gradient-1.png" alt=""><br><img src="/media/6.s191-policy-gradient-2.png" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.youtube.com/playlist?list=PL3FW7Lu3i5JvHM8ljYj-zLfQRF3EO8sYv" target="_blank" rel="noopener">CS231n: Convolutional Neural Networks for Visual Recognition</a> 2017</li><li>Introduction to Deep Reinforcement Learning <a href="https://www.youtube.com/watch?v=zR11FLZ-O9M&list=PLrAXtmErZgOeiKm4sgNOknGvNjby9efdf" target="_blank" rel="noopener">6.S091</a>, <a href="https://www.youtube.com/watch?v=i6Mi2_QM3rA&list=PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI" target="_blank" rel="noopener">6.S191</a>, 2019</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;神经网络&quot;&gt;&lt;a href=&quot;#神经网络&quot; class=&quot;headerlink&quot; title=&quot;神经网络&quot;&gt;&lt;/a&gt;神经网络&lt;/h4&gt;&lt;p&gt;后向传播其实就是使用导数的链式法则&lt;br&gt;&lt;img src=&quot;/media/cs231n-backprop-example1
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>神经网络和深度学习</title>
    <link href="http://note.49px.com/nndl/"/>
    <id>http://note.49px.com/nndl/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2017-11-14T04:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Michael Nielsen的入门教程，从零开始构建一个识别mnist手写数字的神经网络。</p><h4 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h4><p>反向传播就是链式求导过程，训练过程拆细了说有四个方程。这里引入记号$\delta^{(l)}=\frac{\partial C}{\partial z^{(l)}}$，即”误差”$\delta^{(l)}$是关于未激活加权值$z^{(l)}$的偏导数。又$a^{(l)}=g(z^{(l)})$，$z^{(l)}=w^{(l)}a^{(l-1)}+b^{(l)}$，权重$w^{(l)}$的维数是<code>{第l层neuron数} x {第l-1层neuron数}</code>。</p><ul><li>输出层误差：$\delta^{(L)}=\frac{\partial{C}}{\partial{a^{(L)}}} \frac{\partial{a^{(L)}}}{\partial{z^{(L)}}}=\frac{\partial{C}}{\partial{a^{(L)}}} g\prime(z^{(L)})$。</li><li>其他层误差$\delta^{(l)}$用下一层误差$\delta^{(l+1)}$表示：$\delta^{(l)}=\frac{\partial{C}}{\partial{z^{(l+1)}}} \frac{\partial{z^{(l+1)}}}{\partial{a^{(l)}}} \frac{\partial{a^{(l)}}}{\partial{z^{(l)}}}=\frac{\partial{C}}{\partial{z^{(l+1)}}} \frac{\partial{(w^{(l+1)}a^{(l)}+b^{(l+1)})}}{\partial{a^{(l)}}} \frac{\partial{a^{(l)}}}{\partial{z^{(l)}}}=(w^{(l+1)})^T \delta^{(l+1)} g\prime(z^{(l)})$</li><li>层权重的偏导数：$\frac{\partial{C}}{\partial{w^{(l)}}}=\frac{\partial{C}}{\partial{z^{(l)}}} \frac{\partial{z^{(l)}}}{\partial{w^{(l)}}}=\frac{\partial{C}}{\partial{z^{(l)}}} \frac{\partial{(w^{(l)}a^{(l-1)}+b^{(l)})}}{\partial{w^{(l)}}}=\delta^{(l)}(a^{(l-1)})^T$</li><li>层偏置的偏导数：$\frac{\partial{C}}{\partial{b^{(l)}}}=\frac{\partial{C}}{\partial{z^{(l)}}} \frac{\partial{z^{(l)}}}{\partial{b^{(l)}}}=\frac{\partial{C}}{\partial{z^{(l)}}} \frac{\partial{(w^{(l)}a^{(l-1)}+b^{(l)})}}{\partial{b^{(l)}}}=\delta^{(l)}$</li></ul><p>由这四个方程就能写出backprop()代码，见<code>network.py</code>。</p><h4 id="训练过程的改进"><a href="#训练过程的改进" class="headerlink" title="训练过程的改进"></a>训练过程的改进</h4><h5 id="用交叉熵代价函数"><a href="#用交叉熵代价函数" class="headerlink" title="用交叉熵代价函数"></a>用交叉熵代价函数</h5><p>若反向传播时对权重w和偏置b的梯度太小就学习缓慢，看上面方程知这两梯度跟$\delta^{(l)}$有关。考查输出神经元，$\delta^{(l)}$就是$\delta^{(L)}=\frac{\partial{C}}{\partial{a^{(L)}}} g\prime(z^{(L)})$。</p><p>使用L2代价函数 $C=\frac{1}{2}\sum_j(y_j-a_j)^2$、sigmoid激活，$\delta^{(L)}=(a^{(L)}-y) g\prime(z^{(L)})$，跟sigmoid斜率有关，sigmoid饱和时学习缓慢。</p><p>可用交叉熵 $C=-\frac{1}{n}\sum\limits_x{[y\ln a+(1-y)\ln(1-a)]}$ 作代价函数，因为满足非负、且网络表现好（预测值a接近实际值y、y为0或1）时代价接近0。使用交叉熵、sigmoid激活，$\delta^{(L)}=a^{(L)}-y$，无学习缓慢问题。</p><p>多分类时用softmax作输出层的激活函数，输出可理解为概率分布。可用对数似然 $C=-\ln a_y^{(L)}$ 作代价函数，因为满足非负、且网络表现好（$a_y^{(L)}接近1$）时代价接近0。使用对数似然、softmax激活，$\delta^{(L)}=a_j^{(L)}-y_j$，无学习缓慢问题。</p><h5 id="规范化防止过拟合"><a href="#规范化防止过拟合" class="headerlink" title="规范化防止过拟合"></a>规范化防止过拟合</h5><p>神经网络有大量参数，很容易就过拟合。训练集和测试集上的分类准确率相差越大，过拟合越严重。减轻过拟合的方法，除了增加训练样本、减小网络规模，还有规范化。规范化即在代价函数上添加额外的惩罚，惩罚不涉及偏置。比如L2规范化，添加权重惩罚$\frac{λ}{2n}\sum\limits_w{w^2}, λ&gt;0$，参数λ越大越倾向小的权重；同时，规范化反向传播给权重偏导数添上$\frac{λ}{n}w$，梯度下降变成$w=(1-\frac{αλ}{n}w)-\frac{α}{m}\sum\limits_{x}\frac{\partial{C_x}}{\partial{w}}$（n是训练集大小，m是minibatch大小）。</p><p>规范化的本质是引入一些随机性，Dropout也算一种规范化。在小批量数据上的“前向反向”传播开始前，各隐藏层都随机关闭一定比例的神经元，在剩余子集中做一遍“前向反向”传播；最终选出在不同随机子集中都更健壮的特征。因为权重和偏置是在隐藏层部分神经元关闭的情况下学到的，而实际运行时隐藏层所有神经元都打开，使隐藏层的输出变大。为了补偿这个，将（隐藏层的输出）x（隐藏层神经元参与训练的比例）。</p><h5 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h5><p>正态分布独立变量的和：如果$X \sim N(μ_X, σ_X^2), Y \sim N(μ_Y, σ_Y^2), Z=X+Y$，那么$Z \sim N(μ_X+μ_Y, δ_X^2+δ_Y^2)$。</p><p>考虑某个隐藏神经元，其$z=\sum_j{w_jx_j}+b$，激活函数是sigmoid。若我们用$w \sim N(0,1)$初始化权重，简单想$x_j=1, b=0$时，z就是$n_{in}$个输入$w \sim N(0,1)$相加，$z \sim N(0,n_{in})$。z的方差较大、取值范围较大，容易过饱和、学习缓慢。若我们将正态分布初始值除以$\sqrt{n_{in}}$，即标准差缩小到$\frac{1}{\sqrt{n_{in}}}$，则$w \sim N(0, \frac{1}{n_{in}})$，$z \sim N(0,1)$，避免了过饱和问题。</p><p>若激活函数是ReLU，因为其左半是“死区”，平均算$n_{in}/2$个有效输入，要将正态分布初始值除以$\sqrt{n_{in}/2}$。</p><p>合适的权重初始化可以让学习速度更快。偏置初始化则没有影响，任意值都行。</p><p>交叉熵、规范化、权重初始化改进后的代码，见<code>network2.py</code>。</p><h5 id="含动量的梯度下降"><a href="#含动量的梯度下降" class="headerlink" title="含动量的梯度下降"></a>含动量的梯度下降</h5><p>梯度不直接更新权重，引入“速度”的概念，梯度（加速度）影响速度、速度影响权重（距离）。这样如果在某个梯度方向持续更新，该方向上速度叠加，权重更新得更快。</p><h5 id="设置超参数"><a href="#设置超参数" class="headerlink" title="设置超参数"></a>设置超参数</h5><ul><li>训练集上代价不再下降，而是震荡或增加，学习率太大</li><li>验证集上分类准确率n回合不提升，提前终止训练回合，或尝试减小学习率</li><li>规范化参数先设为0，选个学习率，再选规范化参数，再调学习率</li><li>小批量数据的大小设置相对独立</li></ul><h4 id="深度网络的不稳定梯度问题"><a href="#深度网络的不稳定梯度问题" class="headerlink" title="深度网络的不稳定梯度问题"></a>深度网络的不稳定梯度问题</h4><p>因为反向传播就是链式相乘，网络越深链条越长，前面层因乘积中大量的项导致不稳定的梯度（消失或激增）。</p><p>RNN中的长短期记忆LSTM，就为了解决不稳定梯度问题。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://neuralnetworksanddeeplearning.com/" target="_blank" rel="noopener">Neural Networks and Deep Learning</a>（<a href="https://github.com/zhanggyb/nndl/releases" target="_blank" rel="noopener">中文版</a>）by Michael Nielsen，<a href="https://github.com/mnielsen/neural-networks-and-deep-learning" target="_blank" rel="noopener">代码</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Michael Nielsen的入门教程，从零开始构建一个识别mnist手写数字的神经网络。&lt;/p&gt;
&lt;h4 id=&quot;反向传播&quot;&gt;&lt;a href=&quot;#反向传播&quot; class=&quot;headerlink&quot; title=&quot;反向传播&quot;&gt;&lt;/a&gt;反向传播&lt;/h4&gt;&lt;p&gt;反向传播就是链式
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spark笔记</title>
    <link href="http://note.49px.com/spark/"/>
    <id>http://note.49px.com/spark/</id>
    <published>2017-03-08T16:00:00.000Z</published>
    <updated>2020-01-08T02:12:08.908Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/spark-stack.png" alt=""><br>Spark软件栈构成个集群计算平台。SparkCore对运行在集群上的由很多计算任务组成的应用进行调度、分发和监控。</p><p>Spark对数据的抽象叫RDD（Resilient Distributed Dataset，弹性分布式数据集），是不可变的分布式对象集合，叫“弹性”是因为任何时候都能重算。RDD分成多个分区，分别运行在集群的不同节点上。RDD支持两种操作：transformation和action。转化操作由RDD生成新RDD，如map()和filter()，惰性求值，即第一次在行动操作中用到时才真正计算。行动操作对RDD计算一个结果，如reduce()，默认每次都重新计算RDD，除非RDD显式持久化，默认持久化到JVM堆空间。</p><p>键值对RDD就是Java的Tuple2或Python的元组，可支持操作reduceByKey()、groupByKey()、join()、sortByKey()、countByKey()等</p><p>Spark支持多种输入输出源：</p><ul><li>本地或分布式文件系统：文本文件、JSON、CSV、SequenceFiles（用于键值对数据的Hadoop文件格式）、Protocol Buffers、Java序列化出的对象文件</li><li>Spark SQL：Hive支持的任何表（Apache Hive是Hadoop中常见的结构化数据源）</li><li>JDBC数据库、Cassandra、HBase、elasticsearch</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>《Spark快速大数据分析》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/spark-stack.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Spark软件栈构成个集群计算平台。SparkCore对运行在集群上的由很多计算任务组成的应用进行调度、分发和监控。&lt;/p&gt;
&lt;p&gt;Spark对数据的抽象叫RDD（Resilient 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python数据处理</title>
    <link href="http://note.49px.com/python-data-analysis/"/>
    <id>http://note.49px.com/python-data-analysis/</id>
    <published>2017-01-18T16:00:00.000Z</published>
    <updated>2020-01-08T02:12:08.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="重要的基础库"><a href="#重要的基础库" class="headerlink" title="重要的基础库"></a>重要的基础库</h3><h4 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h4><p>多维数组对象ndarray，向量化数组运算，线性代数运算、傅里叶变换、随机数生成</p><p>作为算法之间传递数据的容器，numpy数组对数值型数据的存储和处理要比python内置的高效</p><h4 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h4><p>Series是一维数据及其索引，类似数组（整数索引）或定长有序的字典</p><p>DataFrame是二维表格，既有列索引又有行索引</p><h4 id="scipy"><a href="#scipy" class="headerlink" title="scipy"></a>scipy</h4><p>解决科学计算中各种标准问题的一组包，主要包括：</p><ul><li>integrate：解微积分方程</li><li>linalg：扩展了由numpy.linalg提供的线性代数运算、矩阵分解功能</li><li>optimize：函数优化器（最小化器）、根查找算法</li><li>signal：信号处理工具</li><li>sparse：稀疏矩阵和系数线性系统求解</li><li>special：许多常用数学函数（如伽玛函数）</li><li>stats：连续或离散概率分布（如密度函数、采样器、连续分布函数）、各种统计检验方法、描述统计法</li><li>weave：利用内联c++代码加速数组计算</li></ul><h3 id="iPython环境"><a href="#iPython环境" class="headerlink" title="iPython环境"></a>iPython环境</h3><p>粘贴剪贴板内容用<code>%cpaste</code></p><p>输入行In[X]的文本保存在<code>_iX</code>变量中，输出行Out[X]的文本保存在<code>_X</code>变量中，最近两个输出结果保存在<code>_</code>（一个下划线）和<code>__</code>（两个下划线）变量中</p><p>可与系统shell交互：<code>output = !cmd $arg</code></p><p>算语句执行时间用<code>%timeit</code></p><p>使对象在Out[]输出时更有意义，给类加上<code>__repr__</code>方法</p><h3 id="NumPy基础"><a href="#NumPy基础" class="headerlink" title="NumPy基础"></a>NumPy基础</h3><p><code>arr.shape</code>说明数组各维度大小，<code>arr.dtype</code>说明数组数据类型</p><p><code>np.arange(n)</code>产生[0,n)序列</p><p><code>np.reshape((m, n))</code>重排成m行n列数组</p><h4 id="切片和索引"><a href="#切片和索引" class="headerlink" title="切片和索引"></a>切片和索引</h4><p>ndarray切片是<strong>原数组的引用</strong>，切片上任何修改都会直接反映到原数组上。这跟python数组切片总是复制数据不同。要想获得ndarray切片的副本需要显式地复制，如<code>arr[5:8].copy()</code></p><p><code>arr[i,j]</code>等价于<code>arr[i][j]</code>；多维数组中，若省略了后面的索引，会返回维度低些的ndarray</p><p>布尔索引：索引中的数组作比较运算，将得到一个布尔数组作为索引。多个布尔数组可以使用 与<code>&amp;</code>、或<code>|</code>、非<code>-</code> 运算。将创建数据的副本。</p><p>花式索引：用整数数组或ndarray作索引。将创建数据的副本。</p><p>使用<code>np.ix_</code>函数选取矩形区域，如<code>arr[np.ix_(rows, columns)]</code></p><hr><p><code>np.where(cond, xarr, yarr)</code>是<code>if cond then xarr else yarr</code>的向量化缩写</p><p><code>arr.sort()</code>就地排序，<code>np.sort(arr)</code>返回排序副本</p><h4 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h4><p><code>mat.T</code>转置</p><p><code>matA.dot(matB)</code>矩阵相乘，奇怪的命名！</p><p><code>solve</code>解Ax=b，其中A为方阵</p><p><code>lstsq</code>求Ax=b的最小二乘解</p><h3 id="pandas入门"><a href="#pandas入门" class="headerlink" title="pandas入门"></a>pandas入门</h3><p>由字典构造DataFrame时，字典一项变为DataFrame一列</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>DateFrame相关参数中<code>columns</code>索引列，<code>index</code>索引行</p><p><code>frame[]</code>式索引：</p><ul><li>用标签是取列（标签切片是闭区间）</li><li>用数字切片或布尔数组是取行</li><li>用布尔DataFrame是取元素</li></ul><p><code>frame.ix[]</code>选取行列：</p><ul><li><code>frame.ix[rows, columns]</code>选取行和列，<code>ix</code>是<code>index</code>缩写</li><li><code>frame.ix[rows]</code>选取行</li><li><code>frame.ix[:, columns]</code>选取列</li></ul><p>由整数索引的pandas对象，根据整数选取数据的操作总是面向标签的，这也包括用ix进行切片</p><hr><p>默认<code>axis = 0</code>按行，一行行操作或所有行聚合；<code>axis = 1</code>按列，一列列操作或所有列聚合</p><p><code>sort_index()</code>排序：</p><ul><li><code>frame.sort_index()</code>按行标签排序</li><li><code>frame.sort_index(axis = 1)</code>按列标签排序</li><li><code>frame.sort_index(by=[&#39;a&#39;,&#39;b&#39;])</code>按某些行列的<strong>值排序</strong></li></ul><p><code>combine_first(frame1, frame2)</code>，先从第一个对象中取值，不行就再去第二个对象中取值</p><p>层次化索引，一个轴上有多级索引。<code>swaplevel(level1, level2)</code>互换两个级别，<code>sortlevel(level)</code>根据某级别的值对数据排序。</p><p><code>set_index()</code>将某些列转换为行索引，<code>reset_index()</code>将行索引转换为列</p><p><code>stack</code>将列索引旋转为最内层行索引，<code>unstack</code>将行索引旋转为最内层列索引</p><h4 id="pivot透视"><a href="#pivot透视" class="headerlink" title="pivot透视"></a>pivot透视</h4><p>将只分一些列名不断append的”长格式”，转换为以某列值为行索引的”宽格式”</p><p><code>frame.pivot(作为行索引的列名, 作为列索引的列名, 作为单元格的列名)</code>；<br>如果忽略最后一个参数，<code>frame.pivot(作为行索引的列名，作为列索引的列名)</code>，其他列会分别作为外层列索引得到一个个DataFrame，这些DataFrame一个个横向拼接起来，得到带两层列索引的DataFrame</p><p>其实，<code>pivot</code>只是一个快捷方式：用<code>set_index</code>创建<code>(行索引名, 列索引名)</code>的两层行索引，再用<code>unstack</code>将内层的<code>(列索引名)</code>转回成列索引</p><hr><p><code>groupby</code>是一个 拆分-应用-合并 的过程：将数据根据特定轴的一个或多个键<strong>拆分</strong>为多组，在分组上<strong>应用</strong>函数产生一个新值，将所有分组的结果<strong>合并</strong></p><p><code>pivot_table</code>按行列分组聚合，对比<code>pivot</code>是只分组不聚合</p><p><code>crosstab</code>按行列分组计数，是特殊的<code>pivot_table</code></p><p>以时间戳（字符串或datetime对象）为索引的Series就是时间序列，有多种时间选择方式</p><h3 id="画图入门"><a href="#画图入门" class="headerlink" title="画图入门"></a>画图入门</h3><p>matplotlib是基础</p><p>在Figure的subplot上绘图</p><p>画线时，颜色（k黑r红 等，或#rgb值）、标记（o圆x叉 等）、线型（<code>--</code>虚线<code>.</code>点线 等）</p><hr><p>seaborn接口更高级</p><h3 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a>scikit-learn</h3><h4 id="模型验证"><a href="#模型验证" class="headerlink" title="模型验证"></a>模型验证</h4><p>5-fold cross-validation<br><img src="/media/5-fold-cross-validation.png" alt=""></p><hr><p>模型复杂度<br><img src="/media/validation-curve.png" alt=""></p><p>注意：训练效果总是好于预测效果</p><hr><p>high-variance模型的样本大小<br><img src="/media/learning-curve-of-high-variance.png" alt=""></p><h4 id="常用模型"><a href="#常用模型" class="headerlink" title="常用模型"></a>常用模型</h4><p>naive bayes 的 <strong>的naive就naive在</strong> 要先假设样本属于某个特定分布，最终的分类效果也只是趋于这个分布，常作为分类任务的初始尝试</p><hr><p>简单线性回归 $y = a_0 + a_1x_1 + a_2x_2 + a_3x_3 + …$，常作为回归任务的初始尝试</p><p>多项式回归 $y = a_0 +a_1x + a_2x^2 + a_3x^3 + …$，可使用线性回归库计算，只要根据$x_n = x^n$先把输入$x$变换成 $x, x^2, x^3, …$。其他非线性回归类似，只要根据$x_n = f_n(x)$先把输入$x$变换即可。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>《利用Python进行数据处理》</li><li><a href="https://github.com/jakevdp/PythonDataScienceHandbook" target="_blank" rel="noopener">Python Data Science Handbook</a></li><li><a href="http://cs231n.github.io/python-numpy-tutorial/" target="_blank" rel="noopener">Python Numpy Tutorial</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;重要的基础库&quot;&gt;&lt;a href=&quot;#重要的基础库&quot; class=&quot;headerlink&quot; title=&quot;重要的基础库&quot;&gt;&lt;/a&gt;重要的基础库&lt;/h3&gt;&lt;h4 id=&quot;numpy&quot;&gt;&lt;a href=&quot;#numpy&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://note.49px.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>线性代数的本质</title>
    <link href="http://note.49px.com/linear-algebra/"/>
    <id>http://note.49px.com/linear-algebra/</id>
    <published>2016-12-25T16:00:00.000Z</published>
    <updated>2020-01-08T02:12:08.987Z</updated>
    
    <content type="html"><![CDATA[<p>线性代数围绕两种基本运算：向量加法和向量数乘</p><p>向量：都指列向量。向量可看作是，把基向量i^, j^, …分别按照向量各数值缩放后的和</p><p>生成空间：一组向量线性组合后所能到达的点的集合</p><p>线性相关：如果某个向量落在<em>其它向量</em>的生成空间内，这个向量就与<em>其它向量</em>线性相关</p><p>线性变换：保持网格线平行且等距分布 的原点不变变换</p><p>左边乘矩阵M：跟线性变换等价，把基向量i^, j^, …分别变换成A的各列向量</p><p>行列式：线性变换的空间（二维面积或三维体积）缩放比例，负值表示空间被翻转（正向依右手定律）</p><p>行列式为0：线性变换将空间压缩到更小的维度上</p><p><img src="/media/Ax=v.png" alt=""></p><p>解线性方程组，就是要找未知向量x，x经过A变换后将变成v。要解线性方程组，需要看变换A是否将空间压缩到了更小的维度上，也就是看det(A)是否为0。如果det(A)≠0，不压缩空间，A的逆变换存在，$x = A^{-1} * v$。如果det(A)=0，压缩空间，逆变换不存在，x有解仅当v正好落在压缩后的空间内。比如说A将平面压缩为一条直线，x有解仅当v正好落在这直线上。</p><p>特别地，对于线性方程组Ax=0，x讲过A变换后变成零空间。若A不压缩空间，只能x=0。若x有非零解，只能A压缩空间，det(A)=0。</p><p>若变换A压缩空间，肯定有一个过原点的直线（降一维）或平面（降两维）被压缩到原点，这个被压缩的直线或平面就叫矩阵A的”零空间”或”核”，也是方程组Ax=0的解空间</p><p>秩：变换后（可能降维）的空间维数叫做变换的<strong>秩</strong></p><p>满秩矩阵：变换后不降维</p><p>非方阵：mxn矩阵表示从n维空间到m维空间的变换</p><p><img src="/media/dot-product.png" alt=""><br>点积：两个向量的点积就是 一个向量在另一个向量上的投影长度 * 另一个向量的长度，方向不同时取负号</p><p><img src="/media/cross-product.png" alt=""></p><p>叉积：等价于 列向量矩阵的行列式（正向依右手定律）</p><p>基变换：其他基组在本坐标系下构成列向量矩阵P，P表示从其他基到本基的变换</p><p>相似矩阵：表达式 $P^{-1} * A * P$ 代表同一变换的一种视角转换，中间矩阵A代表你所见的变换，外侧两矩阵代表视角的转换。$P^{-1} * A * P$ 叫做相似矩阵，与A代表着同一个变换，只不过是从其他基的角度来看。总结就是，相似矩阵是同一变换的不同描述矩阵。</p><p>特征向量和特征值：线性变换后仍停留在原先直线上只被拉伸或压缩的向量叫做特征向量，拉伸或压缩的比例叫做特征值</p><p>特征基：若线性变换M有足够的特征向量，可从中选出能张成全空间的一些特征向量作为基，则在特征基视角下的相似矩阵 $P^{-1} * A * P$ 为对角矩阵（因为特征基只被拉伸或压缩），这种”相似对角化”可以简化计算</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.bilibili.com/video/av6731067/" target="_blank" rel="noopener">线性代数的本质</a></li><li><a href="https://www.youtube.com/channel/UCYO_jab_esuFRV4b17AJtAw" target="_blank" rel="noopener">3Blue1Brown@youtube</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线性代数围绕两种基本运算：向量加法和向量数乘&lt;/p&gt;
&lt;p&gt;向量：都指列向量。向量可看作是，把基向量i^, j^, …分别按照向量各数值缩放后的和&lt;/p&gt;
&lt;p&gt;生成空间：一组向量线性组合后所能到达的点的集合&lt;/p&gt;
&lt;p&gt;线性相关：如果某个向量落在&lt;em&gt;其它向量&lt;/em
      
    
    </summary>
    
    
    
      <category term="math" scheme="http://note.49px.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="http://note.49px.com/machine-learning/"/>
    <id>http://note.49px.com/machine-learning/</id>
    <published>2016-10-17T16:00:00.000Z</published>
    <updated>2020-01-08T02:12:08.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>数据集已有正确答案，预测新数据的答案。预测连续值就是回归问题，预测离散值就是分类问题。</p><h4 id="模型、代价函数"><a href="#模型、代价函数" class="headerlink" title="模型、代价函数"></a>模型、代价函数</h4><p>假设模型可以用h函数表示但参数未知，机器学习使用训练集为h训练参数，算出参数后的h就可以做些预测。<br><img src="/media/ml-h-func.png" alt=""></p><p>要训练得到怎样的参数？要得到使代价函数最小化的参数。<br>代价函数是关于这些未知参数的函数。比如线性回归的h函数是关于n维特征的多项式$h_θ(x)=θ_0+θ_1x_1+θ_2x_2+…+θ_nx_n=θ^Tx$，可选平方误差作代价函数<img src="/media/ml-cost-func-linear-regression.jpg" alt="">)，其中$x^{(i)}$、 $y^{(i)}$指第i个样本的值。</p><h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><p>求最小化代价函数的参数，就是求函数取极值时的变量值。可用梯度下降法来迭代逼近局部最小值，当代价函数是凸函数时局部最小值就是全局最小值。所谓梯度，是指包含所有一阶偏导数的向量。</p><p>比如上面的线性回归问题，梯度下降法初始时先随便取组θ值，每次迭代就是各个维度都减去一点自己维上的梯度。相当于先在J(θ)的n+1维曲面上随便取个点，然后取周围使n+1维梯度下降最快的那个点，一步步迭代达到局部极小值。</p><p>比如2维的，<br><img src="/media/ml-gradient-descent-order-2.png" alt=""><br>其中的α叫学习率，α太小下降太慢，α太大可能越过最低点来回振荡无法收敛。</p><p>当有多个特征时，各特征的取值范围可能差别很大，在用梯度下降前要先把各特征值归一到较小区间，比如[-1,1]。方法比如将原先的$x_i$换成$\frac{x_i-μ_i}{range(x)}$或$\frac{x_i-μ_i}{std(x)}$。</p><p>梯度下降每次迭代要在所有m个样本上计算，速度太慢。实践中先把样本顺序打乱，然后每次在b个样本的minibatch上梯度下降，这就叫<strong>随机梯度下降</strong>。下图中b=1。<br><img src="/media/ml-stochastic-gradient-descent.png" alt=""></p><h4 id="方程求解法"><a href="#方程求解法" class="headerlink" title="方程求解法"></a>方程求解法</h4><p>直接求解训练集m个样本构成的方程组。把m个样本的特征数据排成<code>m*(n+1)</code>的矩阵X（注$x_0=1$），m个样本的结果数据排成<code>m*1</code>的向量y，则$Xθ=y, X^TXθ=X^Ty, θ=(X^TX)^{-1}X^Ty$。之所以先$X^TX$可能为了先转成方阶再求逆。Octave代码<code>pinv(X&#39;*X)*X&#39;*y</code>，pinv是求伪逆。当然，向量化时也可把m个样本的特征数据排成<code>(n+1)*m</code>的矩阵，m个样本的结果数据排成<code>1*m</code>的向量y，然后$θ^TX=y$，这样就跟单样本时$θ^Tx=y$形式相同。</p><p>方程法不需要选择学习率α，不需要将多特征的特征值归一到较小区间；缺点是求逆运算$O(n^3)$，n不能太大。</p><hr><h4 id="二元分类"><a href="#二元分类" class="headerlink" title="二元分类"></a>二元分类</h4><p>就是逻辑回归，用sigmoid函数将线性回归的值域变成(0,1)，值&gt;=0.5取y=1、值&lt;0.5取y=0，这样就成了二元分类。</p><p>也就是说，逻辑回归模型的h函数是$h_θ(x)=g(θ^Tx)$，其中$g(z)=\frac{1}{1+e^{-z}}$叫sigmoid函数或logistic函数，h(x)表示y=1的概率。对二元分类，由sigmoid曲线知，$θ^Tx&gt;=0$取y=1，$θ^Tx&lt;0$取y=0，$θ^Tx$就叫决策边界。<br><img src="/media/ml-sigmoid-func.png" alt=""><br>sigmoid性质：$g’(z)=\frac{d}{dz}g(z)=g(z)(1-g(z))$</p><p>逻辑回归的代价函数定义如下，可以保证为凸函数：<br><img src="/media/ml-cost-func-logistic-regression.jpg" alt=""><br>其中$h_θ(x^{(i)})$为样本预测值，$y^{(i)}$为样本实际值。合成一个：<br><img src="/media/ml-cost-func-logistic-regression-compact.jpg" alt=""><br>同样，需要得到使代价函数最小化的未知参数θ。可先算出一阶偏导数构成的梯度向量，然后用梯度下降法求解。</p><h5 id="扩展到多元分类"><a href="#扩展到多元分类" class="headerlink" title="扩展到多元分类"></a>扩展到多元分类</h5><p>为每个类训练一个“属于该类而不属于其他类”的”一对余“二元分类器，训练集的标签向量y要先转变成值为0或1的向量参与训练。要预测新数据属于哪一类，先计算新数据属于各个类的概率，取概率最大的那个类。</p><hr><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><p>当特征太多时，模型容易太复杂、容易过拟合。为了防止过拟合，可以人工去掉一些不重要的特征，可以保留所有特征但减小特征参数$θ_j$（正则化）。</p><p>正则化范数惩罚$θ<em>j$, j=[1..n]但不罚$θ_0$。在代价函数中加上$\frac{λ}{2m}\sum</em>{j=1}^{n}θ_j^2$，λ越大则最终$θ_j$越小。λ叫正则化参数，这里除以2m是为了以后计算时方便。</p><p>线性回归和逻辑回归的梯度计算相同<br><img src="/media/ml-gradient-regularized.jpg" alt=""><br>梯度下降法也相同<br><img src="/media/ml-gradient-descent-regularized.jpg" alt=""><br>方程求解法正则化后变成<br><img src="/media/ml-normal-equation-regularized.jpg" alt=""></p><hr><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p>处理非线性分类需要非线性的h函数，否则多项式h函数的特征数将指数级爆炸。</p><p>神经网络把逻辑单元（模拟神经元）按层组织。每个逻辑单元是个二元分类（逻辑回归），输入是一个总为1的偏置单元和上一层所有的逻辑单元。这样每层就是个多元分类，整个神经网络就是一层层的多元分类。</p><p>计算梯度的过程先前向传播计算各层输出、再反向传播计算各层梯度，反向一层层梯度计算其实就是“计算图”的导数链式计算。</p><h5 id="前向传播计算各层输出"><a href="#前向传播计算各层输出" class="headerlink" title="前向传播计算各层输出"></a>前向传播计算各层输出</h5><p>$a^{(l)}$表示第l层输出（作为下一层输入时要记得添上那总为1的第一分量），$Θ^{(l)}$表示第l层到下一层的系数矩阵（{下一层单元数}行 x {这一层单元数+1}列），设$z^{(l)}=Θ^{(l)}a^{(l)}$，则$a^{(l+1)}=g(z^{(l)})$。</p><h5 id="反向传播计算各层梯度"><a href="#反向传播计算各层梯度" class="headerlink" title="反向传播计算各层梯度"></a>反向传播计算各层梯度</h5><p>前向传播在知道一层到下一层的系数矩阵时计算下一层的值，但各层系数矩阵是未知的，需要我们通过最小化代价函数训练出来。神经网络的代价函数，是最终层逻辑单元的代价函数和（加上前面各层系数矩阵的正则化惩罚）。要最小化代价函数J(Θ)，需求得各层梯度，即各层系数矩阵的偏导数$D_{ij}^{(l)}=\frac{\partial}{\partialΘ_{ij}^{(l)}}J(Θ)$。反向传播反向计算各层误差，最终算出各层梯度。这里引入记号，把J(Θ)关于$z_j^{(l)}$的偏导数$δ_j^{(l)}$叫做“误差”。</p><p>反向传播的过程：对每一个样本，先前向传播计算各层输出$a^{(l)}$，再从最后一层往回倒，反向计算各层误差$δ^{(l)}=(Θ^{(l)})^Tδ^{(l+1)} .* g’(z^{(l)}), g’(z^{(l)})=a^{(l)}.*(1-a^{(l)})$并累加$Δ^{(l)} = Δ^{(l)}+δ^{(l+1)}(a^{(l)})^T$，初始误差$δ^{(L)}=a^{(L)}-y$。处理完所有样本后，偏导数取平均值$D_{ij}^{(l)}=\frac{1}{m}Δ<em>{ij}^{(l)}$ if j=0，$D</em>{ij}^{(l)}=\frac{1}{m}Δ<em>{ij}^{(l)}+\frac{λ}{m}Θ</em>{ij}^{(l)}$ if j≥1。</p><p>注：初始化系数矩阵要用[-ε,ε]的随机小值。若用相同值将导致下层各逻辑单元毫无差别，若用大值将使sigmoid值接近1或0，斜率小梯度下降收敛慢。<br>后向传播计算结果可近似验证$\frac{d}{dθ_i}J(θ) ≈ \frac{J(θ_1,…,θ_i+ε,…,θ_n)-J(θ_1,…,θ_i-ε,…,θ_n)}{2ε}$。</p><p><img src="/media/ml-neural-network-training.jpg" alt=""></p><p><img src="/media/ml-forward-backward-functions.png" alt=""></p><h5 id="关于激活函数"><a href="#关于激活函数" class="headerlink" title="关于激活函数"></a>关于激活函数</h5><p>这里用sigmoid函数作例子，实际上可以为各层选择不同的激活函数。比如输出层还用sigmoid作二元分类；隐藏层可用tanh函数（相当于sigmoid平移缩放过原点），或更常见的ReLU函数<code>g(z)=max{0,z}</code>（Rectified Linear Unit，Geoffrey Hinton已证明ReLu几乎等同于一叠logistic单元）。<br>sigmoid函数：$g(z)=\frac{1}{1+e^{-z}}, g’(z)=g(z)(1-g(z))$<br>tanh函数：$g(z)=\frac{e^z-e^{-z}}{e^z+e^{-z}}, g’(z)=1-g^2(z)$<br>ReLU函数：$g(z)=max(0,z), g’(z)=\begin{cases} 0&amp; \text{if x&lt;0}\ 1&amp; \text{if x≥0}\end{cases}$<br>leaky ReLU函数：$g(z)=max(0.01z, z), g’(z)=\begin{cases} 0.01&amp; \text{if x&lt;0}\ 1&amp; \text{if x≥0}\end{cases}$</p><hr><h4 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h4><p>非线性的h函数不知啥样不妨碍。只要知道代价函数J(θ)、算出梯度、训练出θ，就能预测 y=1 if $θ^Tx≥0$。</p><p>SVM的代价函数可从逻辑回归的代价函数推广得到：</p><ol><li>将代价函数从曲线变成分段线性的$cost_1(z)$和$cost_0(z)$<br><img src="/media/ml-cost-func-svm-from-1.jpg" alt=""><br><img src="/media/ml-cost-func-svm-from-2.jpg" alt=""></li><li>要最小化J(θ)，m倍数无所谓，A+λB变成CA+B形式（C=1/λ），就得到<br><img src="/media/ml-cost-func-svm.jpg" alt=""></li></ol><p>SVM是一种大间距二元分类器，最小化J(θ)造成决策边界在类间保持较大间距。<br><img src="/media/ml-svm-large-margin.png" alt=""><br>异常点存在时，小C值的间距大。<br><img src="/media/ml-svm-large-margin-with-outlier.png" alt=""></p><p>SVM是一种线性分类器，但实践中可以构造新特征并在新特征的维度上线性可分，这样就可应用于非线性问题。</p><h5 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h5><p>把a维特征通过某种变换变成b维特征，这变换就叫kernel（核函数）。SVM通常用核函数把数据点映射到高维空间，低维空间上不好分，高维空间上容易分。<br><img src="/media/ml-svm-kernel-example.jpg" alt=""><br>如图中，通过3个landmark把2维特征x变成3维特征f，这里similarity函数就是kernel。<br>具体来说，这里用了高斯kernel：$f_i=similarity(x,l^{(i)})=exp(-\frac{||x-l^{(i)}||^2}{2σ^2})$。当x接近$l^{(i)}$，$f_i≈1$；当x远离$l^{(i)}$，$f_i≈0$；带宽σ越大，x远离$l^{(i)}$时$f_i$越慢下降到0。</p><p>由于涉及多维特征，kernal变换前记得先特征值归一化。kernel变换后，最小化新特征f的代价函数来训练θ，对新数据x先转换成f表示后再预测 y=1 if $θ^Tf&gt;=0$。</p><p>实践中若有m个样本x，就每个样本作一个landmark，得m个landmark。也就是说，把特征x变换成m维新特征f。</p><hr><h3 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h3><p>把无标签数据集分簇。</p><h4 id="k-means"><a href="#k-means" class="headerlink" title="k-means"></a>k-means</h4><p>优化目标是最小化所有点与它们簇中心的距离平方和：<br><img src="/media/ml-cost-func-kmeans.jpg" alt=""><br>算法的两步正是固定μ优化c、固定c优化μ：<br><img src="/media/ml-algo-kmeans.jpg" alt=""></p><p>簇数K通常是看数据分布后手动设置，初始化的K个簇中心是随机选的K个数据点。运行时如果某簇中心没有分配到数据点，这簇中心通常直接删掉，偶尔也可重新随机化。为防止k-means陷入局部最优解，要多次运行k-means取最小代价函数值。</p><h4 id="特征降维：主成分分析"><a href="#特征降维：主成分分析" class="headerlink" title="特征降维：主成分分析"></a>特征降维：主成分分析</h4><p>把n维点投射到k维面，最小化所有点与投射面的距离平方和$\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}-x_{approx}^{(i)}||^2$。</p><p><img src="/media/ml-algo-pca.jpg" alt=""><br>在训练集计算协方差矩阵Sigma，将Sigma奇异值分解，取矩阵U的前k列。然后不管训练集验证集测试集，投射X到Z用$Z=XU_k$，从Z倒推回X用$X≈ZU_k^T$。</p><p>怎么选择参数k？<br><img src="/media/ml-pca-choose-k.jpg" alt=""></p><h4 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h4><p><img src="/media/ml-algo-anomaly-detection.jpg" alt=""><br>选出有助于异常检测的n个特征，每一维特征用训练集算出$μ_j$和$σ_j^2$，然后对新数据点累乘所有特征的正态分布概率，总概率太小就是异常点。<br>常识：正态分布有68.27%（稍大于2/3）的面积在μ±δ范围内。</p><p>为什么不用分类算法？因为训练数据中异常数据太少、异常类型太多，分类算法无法识别出异常特征。</p><p>怎么选出有助于异常检测的特征？用直方图$hist(x_i)$看特征$x_i$的分布，若不接近正态分布，可尝试变换特征使$f(x_i)$接近正态分布，$f(xi)$变换可以是$log(x_i+c)$、$x_i^{\frac{1}{t}}$等。也可对某异常创建特征，使异常点特征值远离均值（特别大或特别小）。</p><h4 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h4><p>假设我们有一份用户对电影的部分评分表，在左边排列着电影名，在上边排列着用户名。对第j列第i行，$r(i,j)$表示用户j是否对电影i评过分，$y^{(i,j)}$表示用户j对电影i的评分。</p><p>有了这个评分表，我们能知道什么？</p><p>关键要理解两个隐藏变量：电影i的特征$x_i$（假设有n维）、用户j的偏好$θ_j$（维度同$x_i$一样）。如果知道这两个变量，用户j对电影i的评分就为$θ_j^Tx_i$。或者说，所有电影特征按行排列成矩阵X，所有用户偏好按行排列成矩阵Θ。如果知道这两个矩阵，用户对电影的评分矩阵就为$XΘ^T$。<br>如果这两个矩阵只知一个，结合评分表就能线性回归训练出另一个。我们把已知电影特征X求用户偏好Θ的过程，叫做<strong>基于内容的推荐</strong>。<br>如果这两个矩阵都不知道，可先随机赋值、再通过X→Θ→X→Θ→…的迭代求得收敛。实际上，我们能在一步迭代中同时收敛X和Θ，这种同时迭代X和Θ的过程叫做<strong>协同过滤</strong>。</p><h5 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h5><p>代价函数对所有有评分的项(i,j)求和。<br><img src="/media/ml-cost-func-collaborative-filtering.jpg" alt=""><br>梯度，对x或θ的第k维特征求偏导。<br><img src="/media/ml-gradient-collaborative-filtering.jpg" alt=""><br><img src="/media/ml-algo-collaborative-filtering.jpg" alt=""></p><p>若新用户对所有电影都没评分，代价函数最小化会算得该用户偏好为零向量，这没什么用。可先在评分矩阵的每一行减去该行均值，再在新评分矩阵上训练X和Θ，最后算得的预测值再加回均值。<br><img src="/media/ml-collaborative-filtering-mean-normalization.jpg" alt=""></p><p>找相似的电影？$||x_i-x_j||$距离越小越相似。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.coursera.org/learn/machine-learning/" target="_blank" rel="noopener">Machine Learning Course</a> by Andrew Ng, with <a href="https://github.com/smilingpoplar/machine-learning-course" target="_blank" rel="noopener">exercises</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;监督学习&quot;&gt;&lt;a href=&quot;#监督学习&quot; class=&quot;headerlink&quot; title=&quot;监督学习&quot;&gt;&lt;/a&gt;监督学习&lt;/h3&gt;&lt;p&gt;数据集已有正确答案，预测新数据的答案。预测连续值就是回归问题，预测离散值就是分类问题。&lt;/p&gt;
&lt;h4 id=&quot;模型、代价函
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSS笔记</title>
    <link href="http://note.49px.com/css/"/>
    <id>http://note.49px.com/css/</id>
    <published>2016-09-17T16:00:00.000Z</published>
    <updated>2016-09-20T07:35:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>元素浮动就像上浮到上一图层</p><p>假设块元素A是浮动的，如果A在DOM中的<strong>上一元素</strong>是普通流中元素，那么A的顶部和上一元素的底部对齐，也即A的相对垂直位置不变；如果A的<strong>上一元素</strong>也是浮动的，那么A会跟在上一元素的后面，一行放不下时放到下一行。</p><p><strong>清除浮动</strong>时要记住：clear属性只能影响使用clear属性的元素本身</p><p>块元素在普通流中竖向排列，在浮动之后可理解为横向排列，清除浮动可理解为打破横向排列</p><p>浮动元素的原本目的是实现文本环绕，它<em>没有高度</em>不在普通流中，但表现得就像是<em>多行的inline-blocks</em>，占着宽度使文字和其他inline-block环绕。</p><h4 id="闭合浮动"><a href="#闭合浮动" class="headerlink" title="闭合浮动"></a>闭合浮动</h4><p>使浮动元素的父元素像只包含普通流那样高度表现正常。方法有两种：</p><ol><li>给父元素添加<code>.clearfix</code>类，在<code>.clearfix:after</code>伪元素上设置clear属性。这种方法更好</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">' '</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clear属性表明该元素的哪一边不能有浮动元素</p><p>原理是：在元素的margin-top之上添加额外的clearance间隔，使元素盒子最终落在浮动元素的下方，并由这clearance撑起了父元素的高度。</p><p>上述方法第一个浮动元素的的top-margin，会越过父元素的border，与父元素前一元素的bottom-margin重合。要像下面的BFC方法那样使父元素表现为一个独立的盒子，可用这个版本：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">' '</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>触发父元素的BFC来闭合浮动，比如设置父元素的<code>overflow:hidden</code>。这种方法总有副作用</li></ol><p>BFC（<code>Block Formatting Context</code>，css3中叫<code>flow root</code>），就是个独立的盒子，BFC里面元素的布局不会影响外面的元素，而BFC自身是普通流的一部分。触发BFC可以通过设置：</p><ul><li>overflow: hidden|scroll|auto</li><li>float:left|right 或 position: absolute|fixed</li><li>display: inline-block|inline-table|tabel-cell|table-caption</li></ul><p>BFC是个独立的盒子，具体包括：</p><ul><li>margin重叠不能跨越BFC内外</li><li>float元素不能跨越BFC内外</li></ul><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>只有三种定位：普通流、浮动、绝对定位，浮动或绝对定位的元素都会脱离普通流</p><p>absolute定位的基准是<em>最近的positioned祖先</em>（position默认值static，非static值都认为元素已<em>positioned</em>）。所以一般在设置元素<code>posotion:absolute</code>前，先找个祖先元素设置<code>position:relative</code>。</p><p>relative定位不影响元素在普通流中占据的位置，相对于正常位置定位显示。</p><p>fixed定位是特殊的absolute定位，相对于浏览器视窗定位</p><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><p><code>line-height</code>指文本行基线之间的距离</p><p>行框的构造：</p><ol><li>非替换元素的<code>font-size</code>决定内容区高度，<code>line-height</code>值减去<code>font-size</code>值就是行间距，行间距的一半分别加到内容区的顶部和底部构成<em>行内框</em>；<strong>替换元素</strong>（如<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>等）的 height/padding/border/<strong>margin</strong>都加起来构成行内框高度</li><li>将各元素的基线与行基线对齐，替换元素的基线在其<code>margin-bottom</code>下边缘</li><li>指定了<code>vertical-align</code>的元素对其行内框作垂直偏移</li><li>最高行内框顶端和最低行内框底端之间构成<em>行框</em></li></ol><p>替换元素的padding/border/margin都起作用，影响行内框高，但line-height值不变（在垂直对齐时有用）。对非替换元素，左右方向的padding/border/margin起作用；上下padding/border尽管视觉上有影响，但不影响行内框的高度（=内容区高+行间距），不影响行框的构造；上下margin不起作用。</p><blockquote><p>行内元素基本上会作为一行放置，然后分成多个部分。可以把行内元素想成是一个纸片，外围有一些塑料边。在多行上显示行内元素就像是把一个大纸片剪成一些小纸片，每个小纸片上不会增加额外的塑料边，所以看上去只是原来纸片（行内元素）的最前和最后两端出现塑料边。</p></blockquote><p><code>inline-block</code>作为替换元素放在行中，默认是基线对齐的。用来布局时要用<code>vertical-align:top|bottom|middle</code>显式对齐一下，否则内容不同将无法对齐：无文字时基线是容器的<code>margin-bottom</code>下边缘，有文字时基线是最后一行文字的基线。</p><hr><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="http://www.cnblogs.com/iyangyuan/archive/2013/03/27/2983813.html" target="_blank" rel="noopener">CSS浮动(float,clear)通俗讲解</a></li><li><a href="http://fuseinteractive.ca/blog/understanding-humble-clearfix" target="_blank" rel="noopener">Understanding the Humble Clearfix</a></li><li><a href="http://zh.learnlayout.com/position.html" target="_blank" rel="noopener">学习css布局：position</a></li><li><a href="http://www.cnblogs.com/qieguo/p/5421252.html" target="_blank" rel="noopener">这可能是史上最全的CSS自适应布局总结教程</a></li><li>《CSS权威指南(第3版)》  <em>by Meyer</em></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浮动&quot;&gt;&lt;a href=&quot;#浮动&quot; class=&quot;headerlink&quot; title=&quot;浮动&quot;&gt;&lt;/a&gt;浮动&lt;/h3&gt;&lt;p&gt;元素浮动就像上浮到上一图层&lt;/p&gt;
&lt;p&gt;假设块元素A是浮动的，如果A在DOM中的&lt;strong&gt;上一元素&lt;/strong&gt;是普通流中元素，
      
    
    </summary>
    
    
    
      <category term="web" scheme="http://note.49px.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记</title>
    <link href="http://note.49px.com/docker/"/>
    <id>http://note.49px.com/docker/</id>
    <published>2016-08-18T16:00:00.000Z</published>
    <updated>2016-08-22T08:43:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker-engine"><a href="#docker-engine" class="headerlink" title="docker engine"></a>docker engine</h3><p>包含client和daemon，client（如<code>docker</code>命令）通过restful接口与daemon通讯</p><p>daemon管理着3种资源：</p><ul><li>image，只读，分层，是程序运行的”源文件”</li><li>registry，保存image的地方</li><li>container，在隔离用户空间运行的程序</li></ul><p>注：<em>docker machine</em>用来设置运行着engine主机，以后不用了，用<em>docker Mac</em>代替</p><h3 id="docker-image"><a href="#docker-image" class="headerlink" title="docker image"></a>docker image</h3><p><code>union mount</code>把许多filesystem一层层mount到一起。container在启动装载了image的所有层后，在最上面会再mount一层可读写filesystem，我们要container执行的进程将在这一层执行。</p><p>读写层初始是空的，当我们修改文件时，文件会从下面的只读层拷贝到读写层。初始的只读文件依然存在，但被上面的读写层拷贝所隐藏。这就是所谓的<code>copy on write</code>。</p><p><code>docker images</code> image列表</p><p><code>docker rmi &lt;image&gt;</code> 删除image</p><h4 id="通过Dockfile构建image"><a href="#通过Dockfile构建image" class="headerlink" title="通过Dockfile构建image"></a>通过Dockfile构建image</h4><p><code>Dockfile</code>执行每条命令都相当于：给image添加一层，<code>docker commit</code>提交新image，从新image运行新container</p><p><code>docker build -t &lt;image-name&gt;</code> 根据<code>Dockfile</code>构建image</p><h3 id="docker-volume"><a href="#docker-volume" class="headerlink" title="docker volume"></a>docker volume</h3><p>volume是绕过了<code>union mount</code>机制的指定目录，使数据保存功能可以独立于容器。</p><p><code>docker run -v &lt;host-dir&gt;:&lt;container-dir&gt;[:&lt;rw-mode&gt;]</code> 用<code>-v</code>选项指定volume对应着主机的哪个目录</p><p>还有一种用法叫<em>docker volume container</em>，<code>docker run -v &lt;container-dir&gt;[:&lt;rw-mode&gt;] --name=&lt;volume-container-name&gt;</code>，不用知道也无法知道数据存在主机的哪个目录，其他容器通过<code>docker run --volumes-from=&lt;volume-container-name&gt;</code>使用该volume。即使所有使用该volume的容器都删除了，volume依然存在。</p><p><em>疑：说无法知道数据存在主机的哪个目录，因为用<code>docker inspect &lt;volume-container&gt;</code>查到的对应目录在主机上竟不存在？</em></p><h3 id="docker-networking"><a href="#docker-networking" class="headerlink" title="docker networking"></a>docker networking</h3><p>把多个容器加入同一网络就可通信，默认网络是网桥模式。当容器创建时，会在容器端和主机端创建一对虚拟接口，相当于管道的两端，一端是容器的网络接口，一端插入主机的默认网桥。</p><p>同一网络中的容器通过<em>容器名</em>和<em>端口号</em>通信。因为docker会自动修改所有容器的<code>/etc/hosts</code>文件，把容器名映射到容器的虚拟内网ip。或者也可在运行<code>docker run -h &lt;host-name&gt; ...</code>时指定主机名。</p><p><code>docker network create &lt;network-name&gt;</code> 创建网络，然后<code>docker run --net=&lt;network-name&gt; ...</code>运行容器或<code>docker network connect &lt;network-name&gt; &lt;container&gt;</code>把已有容器加入网络</p><p><code>docker network inspece &lt;network-name&gt;</code> 查看网络元信息</p><h3 id="docker-orchestration"><a href="#docker-orchestration" class="headerlink" title="docker orchestration"></a>docker orchestration</h3><p>orchestration（编排）指管理多个容器，编排工具有<code>docker-compose</code>、<code>swarm</code>等</p><h4 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h4><p>在<code>docker-compose.yml</code>中配置应用的组件（如images, volumes, links等），然后<code>docker-compose up</code>运行。或着<code>docker-compose up -d</code>来daemon化，然后<code>docker-compose ps</code>查看容器，<code>docker-compose logs</code>查看日志。</p><h4 id="swarm"><a href="#swarm" class="headerlink" title="swarm"></a>swarm</h4><p>把多个docker主机合成一个对外的虚拟主机</p><h3 id="常用docker命令"><a href="#常用docker命令" class="headerlink" title="常用docker命令"></a>常用docker命令</h3><h4 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h4><p><code>docker run -i -t ubuntu /bin/bash</code> 打开终端，<code>-i</code> interactive，<code>-t</code> tty</p><p><code>docker run -d ubuntu /bin/sh -c &quot;...&quot;</code> daemon方式运行，用<code>docker stop &lt;container&gt;</code>停止，<code>docker start &lt;container&gt;</code> 启动，<code>docker attach &lt;container&gt;</code> 再登录</p><p><code>docker run --name=&lt;container-name&gt; ...</code> 给容器命名</p><p><code>docker run -p 8080:80 …</code> 主机端口8080 -&gt; 容器端口80，<code>docker run -d -p 80 ...</code> 主机[32768,61000]随机端口 -&gt; 容器端口80，用<code>docker port &lt;container&gt; &lt;container-port&gt;</code>查看对应的主机端口</p><p><code>docker run -P ...</code> 把容器用到的端口映射到主机的相同端口</p><p><code>docker run --rm ...</code> 运行完就删除的一次性容器 </p><h4 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h4><p><code>docker ps</code>（容器列表：正运行的），<code>docker ps -a</code>（正运行或未运行的），<code>docker ps -l</code>（上次运行的）</p><h4 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h4><p><code>docker inspect &lt;container&gt;</code> 查看容器元信息 </p><h4 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h4><p><code>docker logs &lt;container&gt;</code> 查看容器运行输出，<code>docker logs -f &lt;container&gt;</code>类似于<code>tail -f</code>命令</p><h4 id="docker-top"><a href="#docker-top" class="headerlink" title="docker top"></a>docker top</h4><p><code>docker top &lt;container&gt;</code>类似于<code>top</code>命令</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://segmentfault.com/a/1190000006245007" target="_blank" rel="noopener">后端的轮子（四）— 容器</a></li></ul><ul><li>《The Docker Book》<em>by James Turnbull</em>  i.e.《第一本Docker书》  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;docker-engine&quot;&gt;&lt;a href=&quot;#docker-engine&quot; class=&quot;headerlink&quot; title=&quot;docker engine&quot;&gt;&lt;/a&gt;docker engine&lt;/h3&gt;&lt;p&gt;包含client和daemon，client（如&lt;c
      
    
    </summary>
    
    
    
      <category term="docker" scheme="http://note.49px.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Webpack v1.x 笔记</title>
    <link href="http://note.49px.com/webpack/"/>
    <id>http://note.49px.com/webpack/</id>
    <published>2016-08-03T16:00:00.000Z</published>
    <updated>2016-08-31T10:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="混淆和压缩"><a href="#混淆和压缩" class="headerlink" title="混淆和压缩"></a>混淆和压缩</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span> <span class="string">[</span></span><br><span class="line">  <span class="string">new</span> <span class="string">webpack.optimize.UglifyJsPlugin(&#123;</span></span><br><span class="line">    <span class="attr">compress:</span> <span class="string">&#123;</span> <span class="attr">warnings:</span> <span class="literal">false</span> <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#125;),</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><h5 id="支持jQuery"><a href="#支持jQuery" class="headerlink" title="支持jQuery"></a>支持jQuery</h5><p>先<code>npm install jquery</code>，然后</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">plugins:</span> [</span><br><span class="line">  <span class="keyword">new</span> webpack.ProvidePlugin(&#123; <span class="string">jQuery:</span> <span class="string">'jquery'</span> &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="生成html入口文件"><a href="#生成html入口文件" class="headerlink" title="生成html入口文件"></a>生成html入口文件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: <span class="string">'index.template.html'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>template文件如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'root'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>插件会在template的<code>&lt;body&gt;</code>内最后插入js脚本，在<code>&lt;head&gt;</code>内最后插入css样式</p><p><em>参见：</em><a href="http://javascriptplayground.com/blog/2016/07/webpack-html-plugin/" target="_blank" rel="noopener">Using the HTML Webpack Plugin for generating HTML files</a></p><p>用<code>dev-server.js</code>还要修改</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const compiler = webpack(webpackConfig);</span><br><span class="line">...</span><br><span class="line">app.use(<span class="string">'*'</span>, <span class="function"><span class="params">(req, res, <span class="built_in">next</span>)</span> =&gt;</span> &#123;</span><br><span class="line">  const filename = path.join(compiler.outputPath, <span class="string">'index.html'</span>);</span><br><span class="line">  compiler.outputFileSystem.readFile(filename, <span class="function"><span class="params">(err, result)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">next</span>(err);</span><br><span class="line">    res.set(<span class="string">'content-type'</span>, <span class="string">'text/html'</span>);</span><br><span class="line">    res.send(result);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>参见：<a href="https://github.com/ampedandwired/html-webpack-plugin/issues/145" target="_blank" rel="noopener">issue 145</a></p><h5 id="提取vendor模块"><a href="#提取vendor模块" class="headerlink" title="提取vendor模块"></a>提取vendor模块</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">'./package.json'</span>);</span><br><span class="line">...</span><br><span class="line">entry: &#123;</span><br><span class="line">  vendor: <span class="built_in">Object</span>.keys(pkg.dependencies),</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    names: [<span class="string">'vendor'</span>, <span class="string">'manifest'</span>],</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><em>注</em>：<code>CommonsChunkPlugin</code>需要这第二个参数<code>manifest</code>，这样才能在app模块更新时不影响vendor模块的<code>chunkhash</code>值。</p><p>参见：<a href="http://survivejs.com/webpack/building-with-webpack/splitting-bundles/" target="_blank" rel="noopener">Splitting Bundles</a></p><h5 id="资源名hash化"><a href="#资源名hash化" class="headerlink" title="资源名hash化"></a>资源名hash化</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">output</span>: &#123;</span><br><span class="line">  <span class="attribute">filename</span>: <span class="string">'[name].[chunkhash].js'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>name</code>可以理解为<code>entry</code>配置中指定的模块名。 <code>chunkhash</code>是某个分片的hash值，<code>hash</code>是bundle整体的hash值。HMR热更新会与<code>chunkhash</code>冲突，需要HMR热更新的开发环境只能用<code>[name].[hash].js</code>。</p><h5 id="提取css文件"><a href="#提取css文件" class="headerlink" title="提取css文件"></a>提取css文件</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ExtractTextPlugin = require(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line">...</span><br><span class="line"><span class="string">plugins:</span> [</span><br><span class="line">  <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].[chunkhash].css'</span>),</span><br><span class="line">],</span><br><span class="line"><span class="string">module:</span> &#123;</span><br><span class="line"><span class="symbol">  loaders:</span> [</span><br><span class="line">    &#123; <span class="string">test:</span> <span class="regexp">/\.css$/</span>, <span class="string">loader:</span> ExtractTextPlugin.extract(<span class="string">'style'</span>, <span class="string">'css'</span>) &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HMR热更新会与<code>ExtractTextPlugin</code>冲突，需要HMR热更新的开发环境不能用<code>ExtractTextPlugin</code>，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">module</span>: &#123;</span><br><span class="line">  <span class="attribute">loaders</span>: [</span><br><span class="line">    &#123; test: /\.css$/, loader: <span class="string">'style!css'</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启用css-modules"><a href="#启用css-modules" class="headerlink" title="启用css-modules"></a>启用css-modules</h5><p>在loader中加上<code>modules</code>即为启用，<code>localIdentName</code>是设置生成样式的命名规则</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">module</span>: &#123;</span><br><span class="line">  <span class="attribute">loaders</span>: [&#123;</span><br><span class="line">    test: /\.css$/,</span><br><span class="line">    loader: <span class="string">'style!css?modules&amp;localIdentName=[local]__[hash:base64:5]'</span> </span><br><span class="line">  &#125;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>ExtractTextPlugin</code>时：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span>: &#123;</span></span><br><span class="line">  <span class="symbol">loaders:</span> [&#123;</span><br><span class="line">    <span class="symbol">test:</span> /\.css$/,</span><br><span class="line">    <span class="symbol">loader:</span> ExtractTextPlugin.extract(<span class="string">'style'</span>, <span class="string">'css?modules&amp;importLoaders=1&amp;localIdentName=[local]__[hash:base64:5]'</span> </span><br><span class="line">  &#125;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>sass</code>时：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">module</span>: &#123;</span><br><span class="line">  <span class="attribute">loaders</span>: [&#123;</span><br><span class="line">    test: /\.scss$/,</span><br><span class="line">    loader: <span class="string">'style!css?modules&amp;localIdentName=[local]__[hash:base64:5]!sass'</span> </span><br><span class="line">  &#125;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/styles</code>目录是全局样式，其他目录是使用css-modules的局部样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">module</span>: &#123;</span><br><span class="line">  <span class="attribute">loaders</span>: [&#123;</span><br><span class="line">    test: /\.scss$/,</span><br><span class="line">    exclude: path.<span class="built_in">resolve</span>(__dirname, <span class="string">'src/styles'</span>),</span><br><span class="line">    loader: <span class="string">'style!css?modules&amp;localIdentName=[local]__[hash:base64:5]!sass'</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attribute">test</span>: /\.scss$/,</span><br><span class="line">    include: path.<span class="built_in">resolve</span>(__dirname, <span class="string">'src/styles'</span>),</span><br><span class="line">    loader: <span class="string">'style!css!sass'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="去除没用的css"><a href="#去除没用的css" class="headerlink" title="去除没用的css"></a>去除没用的css</h5><p>这个插件较慢，只需在生产环境下使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PurifyCSSPlugin = <span class="built_in">require</span>(<span class="string">'purifycss-webpack-plugin'</span>);</span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> PurifyCSSPlugin(&#123;&#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://lifei.github.io/2015/12/20/webpack/" target="_blank" rel="noopener">基于Webpack的前端资源构建方案</a></li><li><a href="https://github.com/camsong/blog/issues/5" target="_blank" rel="noopener">CSS Modules 详解及 React 中实践</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;混淆和压缩&quot;&gt;&lt;a href=&quot;#混淆和压缩&quot; class=&quot;headerlink&quot; title=&quot;混淆和压缩&quot;&gt;&lt;/a&gt;混淆和压缩&lt;/h5&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="web" scheme="http://note.49px.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Node项目笔记</title>
    <link href="http://note.49px.com/node-project/"/>
    <id>http://note.49px.com/node-project/</id>
    <published>2016-07-26T16:00:00.000Z</published>
    <updated>2016-08-08T03:02:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="共享common代码"><a href="#共享common代码" class="headerlink" title="共享common代码"></a>共享common代码</h4><p>api端和client端要共享某些代码（如utils函数、数据库schema等），可以把这些代码打包成本地npm包：</p><ol><li><p>在代码目录下定义<code>package.json</code> </p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"foo"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用babel将es6编译成es5，拷贝<code>package.json</code>到生成的<code>lib/</code>目录，然后在<code>lib/</code>中打包</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh </span></span><br><span class="line">rm -fr <span class="class"><span class="keyword">lib</span>/ &amp;&amp; <span class="title">babel</span> -<span class="title">d</span> <span class="title">lib</span>/ <span class="title">src</span>/</span></span><br><span class="line">cp package.json <span class="class"><span class="keyword">lib</span>/</span></span><br><span class="line">(cd <span class="class"><span class="keyword">lib</span>/ &amp;&amp; <span class="title">npm</span> <span class="title">pack</span>)</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>lib</code>目录下用<code>npm pack</code>将目录打包成<code>tgz</code>文件，比如你在<code>package.json</code>中设置包名为<code>foo</code>版本为<code>1.0.0</code>，则会生成<code>foo-1.0.0.tgz</code>。还可以通过<code>tar -tf foo-1.0.0.tgz</code>来查看包中内容。</p></li><li><p><code>npm install /path/to/foo-1.0.0.tgz</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;共享common代码&quot;&gt;&lt;a href=&quot;#共享common代码&quot; class=&quot;headerlink&quot; title=&quot;共享common代码&quot;&gt;&lt;/a&gt;共享common代码&lt;/h4&gt;&lt;p&gt;api端和client端要共享某些代码（如utils函数、数据库schema
      
    
    </summary>
    
    
    
      <category term="web" scheme="http://note.49px.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Sass 笔记</title>
    <link href="http://note.49px.com/sass/"/>
    <id>http://note.49px.com/sass/</id>
    <published>2016-07-18T16:00:00.000Z</published>
    <updated>2016-08-30T04:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>变量以<code>$</code>开头，如$var；字符串中使用变量，要用<code>#{}</code>括起来</p><p>标准的css注释<code>/* comment */</code>编译后保留，单行注释<code>// comment</code>编译后忽略</p><p>用<code>@import</code>引入外部文件</p><p><code>%</code>开头的选择器是<code>placeholder selector</code>，编译后忽略</p><p>mixin类似宏，是可重用的代码块，可以指定参数和默认值；用<code>@mixin</code>定义，用<code>@include</code>引用。用<code>@extend</code>继承css类，编译后会在父选择器声明处添上子选择器名。应该多用组合（@mixin）少用继承（@extend），只有当selector间确实存在继承关系时才用继承。</p><h4 id="嵌套selectors"><a href="#嵌套selectors" class="headerlink" title="嵌套selectors"></a>嵌套selectors</h4><p>默认由空格拼接外内selector名</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.item</span> &#123;</span><br><span class="line">  &gt; <span class="string">.item-name</span> &#123; <span class="string">...</span> &#125;    =&gt;    <span class="string">.item</span> &gt; <span class="string">.item-name</span> &#123; <span class="string">...</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>&amp;</code>则直接引用该selector名</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.item</span> &#123;</span><br><span class="line">  &amp;-name &#123; <span class="string">...</span> &#125;    =&gt;    <span class="string">.item-name</span> &#123; <span class="string">...</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译bootstrap"><a href="#编译bootstrap" class="headerlink" title="编译bootstrap"></a>编译bootstrap</h4><h5 id="定制bootstrap"><a href="#定制bootstrap" class="headerlink" title="定制bootstrap"></a>定制bootstrap</h5><p>v3版用bootstrap-sass（<code>npm install bootstrap-sass</code>），先拷贝<code>assets/stylesheets/bootstrap/_variables.scss</code>成<code>_customVariables.scss</code>，再引用bootstrap，最后再引用其他自定义的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">'customVariables'</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">'path-to-bootstrap-sass/assets/stylesheets/bootstrap'</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">'otherCustomStyles'</span>;</span><br></pre></td></tr></table></figure><p>可使用<code>path-to-bootstrap-sass/assets/stylesheets/bootstrap/mixins/</code>中的<code>@mixin</code>，如<code>make-row()</code>、<code>make-*-column()</code>、<code>button-variant()</code>等</p><h5 id="webpack打包"><a href="#webpack打包" class="headerlink" title="webpack打包"></a>webpack打包</h5><p><code>webpack</code>中使用<a href="https://github.com/shakacode/bootstrap-loader" target="_blank" rel="noopener">bootstrap-loader</a>打包bootstrap，配置jQuery时先<code>npm install jquery</code>，然后用说明中的<code>imports-loader</code>，或者用<code>new webpack.ProvidePlugin({ jQuery: &#39;jquery&#39; })</code></p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>用<a href="https://incident57.com/codekit/" target="_blank" rel="noopener">CodeKit</a>来自动编译scss，并实时刷新页面</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">SASS用法指南</a></li><li><a href="https://www.psd2html.com/blog/customize-bootstrap-grid-with-sass.html" target="_blank" rel="noopener">How to Customize Bootstrap Grid with Sass</a></li></ul><hr><h3 id="另：less语法"><a href="#另：less语法" class="headerlink" title="另：less语法"></a>另：less语法</h3><p>变量以<code>@</code>开头，如@var，定义和使用都是@var</p><p>mixin定义时形如<code>.mixin-name(@param1: default1, ...)</code>，使用时形如<code>.minxin-name(...)</code></p><p>嵌套selectors，与sass相同</p><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><ul><li><p><a href="http://www.bootcss.com/p/lesscss/" target="_blank" rel="noopener">LESS « 一种动态样式语言</a></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;变量以&lt;code&gt;$&lt;/code&gt;开头，如$var；字符串中使用变量，要用&lt;code&gt;#{}&lt;/code&gt;括起来&lt;/p&gt;
&lt;p&gt;标准的css注释&lt;code&gt;/* comment */&lt;/code&gt;编译后保留，单行注释&lt;code&gt;// comment&lt;/code&gt;编译后忽略&lt;
      
    
    </summary>
    
    
    
      <category term="web" scheme="http://note.49px.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>RESTful 笔记</title>
    <link href="http://note.49px.com/restful/"/>
    <id>http://note.49px.com/restful/</id>
    <published>2016-07-11T16:00:00.000Z</published>
    <updated>2016-07-12T07:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Http-Status"><a href="#Http-Status" class="headerlink" title="Http Status"></a>Http Status</h4><p>POST创建，返回<code>201 Created</code></p><p>PUT更新应当是幂等操作，返回<code>204 No Content</code></p><p>DELETE删除也可是幂等操作，返回<code>204 No Content</code></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://segmentfault.com/a/1190000005924733" target="_blank" rel="noopener">来自于PayPal的RESTful API标准</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Http-Status&quot;&gt;&lt;a href=&quot;#Http-Status&quot; class=&quot;headerlink&quot; title=&quot;Http Status&quot;&gt;&lt;/a&gt;Http Status&lt;/h4&gt;&lt;p&gt;POST创建，返回&lt;code&gt;201 Created&lt;/code&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="web" scheme="http://note.49px.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>react 笔记</title>
    <link href="http://note.49px.com/react/"/>
    <id>http://note.49px.com/react/</id>
    <published>2016-06-07T16:00:00.000Z</published>
    <updated>2016-08-04T02:28:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>页面inline元素后的<em>换行</em>会被转成一个<em>空格</em>（文字节点），导致inline元素后有<strong>少许空隙</strong>。而react标签后的<em>换行不输出</em>，这样inline元素后没有空隙。统一两者的办法是删除页面inline元素后的换行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>one<span class="tag">&lt;/<span class="name">li</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- or --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>one<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  --&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>two<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><p>用<a href="https://github.com/mzabriskie/axios" target="_blank" rel="noopener">axios</a>向服务端发起异步请求</p><h4 id="normalizr"><a href="#normalizr" class="headerlink" title="normalizr"></a>normalizr</h4><p>拿到服务端返回的json可能多层嵌套，用<a href="https://github.com/paularmstrong/normalizr" target="_blank" rel="noopener">normalizr</a>处理后保存在redux中；使用时用<a href="https://github.com/gpbl/denormalizr" target="_blank" rel="noopener">denormalizr</a>还原</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;页面inline元素后的&lt;em&gt;换行&lt;/em&gt;会被转成一个&lt;em&gt;空格&lt;/em&gt;（文字节点），导致inline元素后有&lt;strong&gt;少许空隙&lt;/strong&gt;。而react标签后的&lt;em&gt;换行不输出&lt;/em&gt;，这样inline元素后没有空隙。统一两者的办法是删除页面inl
      
    
    </summary>
    
    
    
      <category term="node" scheme="http://note.49px.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>bookshelfjs 笔记</title>
    <link href="http://note.49px.com/bookshelf/"/>
    <id>http://note.49px.com/bookshelf/</id>
    <published>2016-01-07T16:00:00.000Z</published>
    <updated>2016-07-13T11:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>bookshelf，连接sql数据库的orm，使用knex生成查询串</p><p><code>where(filter)</code>的filter参数除了可以<code>{id}</code>这样的obj，还可以用<code>q=&gt;{ q.whereIn(&#39;id&#39;, ids); }</code>这样的func，q是<code>knex</code>中的queryBuilder。</p><p><code>fetch(options)</code>的options参数中<code>{ withRelated: [xxx] }</code>可以预取关联的model数据。</p><h4 id="比如一对多关系"><a href="#比如一对多关系" class="headerlink" title="比如一对多关系"></a>比如<code>一对多</code>关系</h4><p>一Book有多Page，一Page属于一Book</p><p><code>一</code>（Book）上可以定义获取<code>多</code>（Page）的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pages() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.hasMany(Page, <span class="string">'pageId'</span>); &#125;</span><br></pre></td></tr></table></figure><p>然后fetch时提供<code>withRelated:</code>来预取：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> book = <span class="function">await Book.<span class="title">fetch</span><span class="params">(&#123; withRelated: [<span class="string">'pages'</span>]&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>之后用<code>book.related(&#39;pages&#39;)</code>访问这个预取的model</p><p><code>多</code>（Page）上可以定义获取<code>一</code>（Book）的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.belongsTo(Book, <span class="string">'bookId'</span>); &#125;</span><br></pre></td></tr></table></figure><p>然后fetch时提供<code>withRelated:</code>来预取：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const<span class="built_in"> page </span>= await Page.fetch(&#123; withRelated: [<span class="string">'book'</span>] &#125;);</span><br></pre></td></tr></table></figure><p>之后用<code>page.related(&#39;book&#39;)</code>访问这个预取的model</p><h4 id="比如多对多关系"><a href="#比如多对多关系" class="headerlink" title="比如多对多关系"></a>比如<code>多对多</code>关系</h4><p>一Buyer买多Item，一Item被多Buyer买</p><p><code>多</code>（如 Buyer）上可以定义获取<code>多</code>（如 Item）的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">items() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.belongsToMany(Item)</span><br><span class="line">  .through(BuyerItem, <span class="string">'buyerId'</span>, <span class="string">'itemId'</span>)</span><br><span class="line">  .withPivot([<span class="string">'buyCount'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>（注：使用.through()时，中间表BuyerItem要有id域）</em></p><p>然后fetch时提供<code>withRelated:</code>来预取：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buyer = <span class="function">await Buyer.<span class="title">fetch</span><span class="params">(&#123; withRelated: [<span class="string">'items'</span>] &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>之后用<code>buyer.related(&#39;items&#39;)</code>访问这个预取的model</p><p>buyer的关联items没有预取时，直接取items：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">await</span> <span class="selector-tag">buyer</span><span class="selector-class">.load</span>(<span class="selector-attr">[<span class="string">'items'</span>]</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="保存时自动hash密码"><a href="#保存时自动hash密码" class="headerlink" title="保存时自动hash密码"></a>保存时自动hash密码</h4><p>在<code>initialize</code>中注册回调函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initialize() &#123;</span><br><span class="line">  bookshelf.Model.prototype.initialize.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">'saving'</span>, util.hashPasswordWithBcrypt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bookshelf.transaction(<span class="keyword">await</span> transacting =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">await</span> xxx.fetch(xxx, &#123; transacting &#125;);</span><br><span class="line">  <span class="keyword">await</span> xxx.save(xxx, &#123; transacting &#125;);</span><br><span class="line">  <span class="keyword">await</span> xxx.destroy(&#123; transacting &#125;);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://wesleytsai.io/2015/07/28/bookshelf-bcrpyt-password-hashing/" target="_blank" rel="noopener">Saving Bcrypt Hashed Passwords to Database with Bookshelf.js</a></li><li><a href="http://blog.ragingflame.co.za/2014/7/21/using-nodejs-with-mysql" target="_blank" rel="noopener">Using Node.js with MySQL</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;bookshelf，连接sql数据库的orm，使用knex生成查询串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;where(filter)&lt;/code&gt;的filter参数除了可以&lt;code&gt;{id}&lt;/code&gt;这样的obj，还可以用&lt;code&gt;q=&amp;gt;{ q.whereIn(&amp;#39
      
    
    </summary>
    
    
    
      <category term="node" scheme="http://note.49px.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Swift 2.0 笔记</title>
    <link href="http://note.49px.com/swift/"/>
    <id>http://note.49px.com/swift/</id>
    <published>2015-10-15T16:00:00.000Z</published>
    <updated>2015-10-17T15:00:45.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>let</code>声明常量，<code>var</code>声明变量</li><li>注释：<code>//</code>和<code>/*...*/</code>，多行注释<code>/*...*/</code>可嵌套！</li><li>句尾分号可省略</li><li>类型别名：<code>typealias AudioSample = UInt16</code></li><li>空合运算符, <code>a ?? b</code>等价于<code>a!=nil ? a! : b</code></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li><code>String</code>是值类型，由编译器保证只在必要时拷贝</li><li>字符串插值：<code>\(...)</code></li><li><code>.characters</code>表示对应的unicode字符组，<code>.characters.count</code>表示所含的unicode字符数</li><li>不能用数字作索引，使用<code>.startIndex</code>、<code>.endIndex</code>、<code>.startIndex.advancedBy(7)</code>等</li><li>相等：==，前缀：.hasPrefix()，后缀：.hasSuffix()</li><li>可赋值给Selector：<code>let mySelector: Selector = “tappedButton:&quot;</code></li></ul><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><ul><li><code>let http404Error = (404, &quot;Not Found&quot;)</code></li><li>只需要一部分元组值，忽略的部分用<code>_</code>标记：<code>let (justTheStatusCode, _) = http404Error</code></li><li>通过下标访问元组元素：<code>http404Error.0</code></li><li>定义元组时给元素命名：<code>let http200Status = (statusCode: 200, description: &quot;OK&quot;)</code>，然后通过名字访问这些元素：<code>http200Status.description</code></li></ul><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><ul><li>数组类型<code>[Int]</code>、集合类型<code>Set&lt;Int&gt;</code>、字典类型<code>[String:Int]</code></li><li>已推断出类型时，<code>[]</code>空数组，<code>[:]</code>空字典</li><li>合并两数组可用<code>+</code></li><li>数组可区间替换，如<code>array[4...6] = [&quot;Bananas&quot;, &quot;Apples&quot;]</code>，把中间三个元素换为两个</li><li>带下标遍历数组，如：<code>for (index, value) in array.enumerate())</code></li><li>集合的值和字典的键必须hashable；所有基本类型（如String, Int, Double, Bool）都hashable</li></ul><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><ul><li>用法一：存储任何类型的关联值，类似union，给enum中各变量声明不同类型（且不赋实际值）  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> UPCA(Int, Int, Int, Int)</span><br><span class="line">    <span class="keyword">case</span> QRCode(String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>用法二：给enum中各变量赋予同类型的原始值（rawValue）  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> Tab = <span class="string">"\t"</span></span><br><span class="line">    <span class="keyword">case</span> LineFeed = <span class="string">"\n"</span></span><br><span class="line">    <span class="keyword">case</span> CarriageReturn = <span class="string">"\r"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  带原始值的枚举类型自带一个failable构造器<code>init?(rawValue:)</code></li><li>关联值是自身这一枚举类型，要在这关联值前用<code>indirect</code>表示该成员可递归  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> Number(Int)</span><br><span class="line">    indirect <span class="keyword">case</span> Addition(ArithmeticExpression, ArithmeticExpression)</span><br><span class="line">    indirect <span class="keyword">case</span> Multiplication(ArithmeticExpression, ArithmeticExpression)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><ul><li>实际上是enum：  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">case</span> None</span><br><span class="line">    <span class="keyword">case</span> Some(T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可空类型（形如<code>Type?</code>），可能存在某个值或不存在值，用<code>someOptional!</code>强制展开</li><li>可空绑定，如<code>if let constName = someOptional { }</code></li><li>可空链式调用，如<code>street = paul.residence?.address?.street</code>，返回的都是可空值（即使原函数返回非空值）</li><li>隐式展开可空值（形如<code>Type!</code>），变量在首次初始化后不再为空（一般作实例变量，由类初始化），直接用<code>someOptional</code>访问</li></ul><h3 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h3><ul><li>if/for/while等的条件语句不需要括号：<code>for index in 1...n</code></li><li>switch的每个值都至少要有个case分支对应，当现有的分支无法涵盖所有值时要使用default分支</li><li>case分支不会fallthrough，不需要显式地<code>break</code>；但可用<code>fallthrough</code>关键字让控制流直接接上下一个case的执行代码（跳过下一个case的条件检查）</li><li>case可以区间匹配（如数值区间<code>3...5</code>，tuple区间<code>(_, 0)</code>，逗号分隔的多个区间<code>1,3,5...7</code>），各case的区间重叠时按序选择匹配</li><li>case中的模式匹配：  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let color = (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">switch</span> color &#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0.0</span>, <span class="number">0.5</span>..<span class="number">.1</span><span class="number">.0</span>, let blue, _):</span><br><span class="line">        print(<span class="string">"Green and \(blue * 100)% blue"</span>)</span><br><span class="line">    <span class="keyword">case</span> let (r, g, b, <span class="number">1.0</span>) where r == g &amp;&amp; g == b:</span><br><span class="line">        print(<span class="string">"Opaque grey \(r * 100)%"</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>循环和switch语句可以加标签，这样多层嵌套时可以break/continue到指定标签</li><li><code>guard</code>语句类似if语句，但<code>guard</code>总是有一个<code>else</code>分句</li></ul><h3 id="Function-amp-Closure"><a href="#Function-amp-Closure" class="headerlink" title="Function &amp; Closure"></a>Function &amp; Closure</h3><ul><li>内外参数同名：<code>func someFunc(paraName: Int) {}</code>；显式指定外部参数名: <code>func someFunc(externalParaName localParaName: Int) {}</code></li><li>参数列表末可以提供默认参数：<code>func someFunc(paraName: Int = 12) {}</code></li><li>可变参数数组，如<code>func mean(numbers: Double...) -&gt; Double {}</code>，最多只能有一个且放在参数列表最最后（默认参数之后）</li><li>参数默认是常量，若要将参数作为可修改副本使用，在参数名前加<code>var</code>：<code>func someFunc(var paraName: String) {}</code></li><li><code>inout</code>参数由外部在调用时传引用<code>&amp;varParam</code>：  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func swapTwoInts(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> _ b: Int) &#123;</span><br><span class="line">    let tmp = a; a = b; b = tmp</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">swapTwoInts(&amp;someInt, &amp;anotherInt)</span><br></pre></td></tr></table></figure></li><li>函数类型由参数和返回值类型组成，如：<code>(Int, Int) -&gt; Int</code>, <code>(Int) -&gt; Int</code>, <code>() -&gt; ()</code></li><li>函数中可以嵌套定义新函数</li><li>闭包语法：  <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (<span class="name">parammeters</span>) -&gt; returnType in</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>闭包可用<code>$0, $1, $2</code>等速记参数：<code>reversed = sort(names, { $0 &gt; $1 })</code></li></ul><h3 id="Struct-amp-Class"><a href="#Struct-amp-Class" class="headerlink" title="Struct &amp; Class"></a>Struct &amp; Class</h3><ul><li>struct不能继承；struct是值类型（传拷贝），class是引用类型（传引用）</li><li>所有基本类型（包括字符串、数组、字典）都是值类型，用struct实现的，编译器会保证只有确实必要时才执行实际拷贝</li><li>struct可以按成员初始化：<code>let vga = Resolution(width: 640, height: 480)</code></li><li><code>lazy var</code>在首次使用时才初始化；全局常量/变量自动是lazy的（不需lazy标记）</li><li>若某实例方法要修改struct/enum等值类型中的属性（包括修改<code>self</code>），得给方法添加<code>mutating</code>声明</li><li>定义下标索引，如：  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subscript(index: <span class="type">Int</span>) -&gt; <span class="keyword">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">set</span>(<span class="keyword">new</span><span class="type">Value</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  也可以是二维的，如：<br><code>subscript(row: Int, column: Int) -&gt; Double { ... }</code> ，访问时可用<code>matrix[1, 0]</code></li><li>子类重载父类特性时要加<code>override</code>声明</li><li>不想被重载的特性用<code>final</code>声明</li><li>类至少有一个designated构造器，它先初始化本类引入的所有存储型属性，然后调用父类的designated构造器（delegate up），再为继承的属性设置新值</li><li>convenience构造器要前加<code>convenience</code>声明，它调用本类的其他构造器并最终调用到某个designated构造器（delegate across），再为任意属性设置新值</li><li>两阶段初始化：就是个中序遍历，先初始化存储型属性，再访问super.init()，再之后算阶段二用来作些自定义</li><li>若子类没有designated构造器，则自动继承父类的designated构造器</li><li>若子类实现了父类的所有designated构造器（不管是自动继承的还是自己实现的），则自动继承父类的convenience构造器</li><li>可失败构造器：<code>init?(...)</code>，若要返回的对象隐式展开：<code>init!(...)</code></li><li>子类都必须实现的构造器，前加<code>required</code>修饰</li><li>用闭包和函数设置属性的默认值：  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">SomeClass</span> &#123;</span><br><span class="line">    let someProperty: SomeType = &#123;</span><br><span class="line">        …</span><br><span class="line">        <span class="keyword">return</span> someValue</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>每个类最多只能有一个析构器<code>deinit</code>，子类析构器的最后会自动调用父类析构器</li></ul><h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><ul><li>对生命周期中会变为nil的实例使用弱引用（weak, optional）</li><li>对初始化赋值后再也不会变为nil的实例使用无主引用（unowned）</li><li>两个类中的属性互相引用，要打破循环强引用：<ul><li>两个都可为nil：其中一个使用弱引用（weak）</li><li>一个可为nil，一个不可为nil：不可为nil的使用无主引用（unowned）</li><li>两个都不可为nil：一个使用隐式展开可空属性（Type!），一个使用无主引用（unowned）</li></ul></li><li>将闭包赋给属性，要打破循环引用，用无主引用来捕获<code>self</code>，如：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazy var someClosure: (Int, <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> = &#123;</span><br><span class="line">    [unowned <span class="keyword">self</span>, weak delegate = <span class="keyword">self</span>.delegate!] (index: Int, stringToProcess: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> <span class="keyword">in</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> someClosure: () -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate = <span class="keyword">self</span>.delegate!] <span class="keyword">in</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h3><ul><li>错误用符合<code>ErrorType</code>协议的值表示：<code>enum VendingMachineError: ErrorType</code></li><li>用<code>throws</code>声明函数将抛出错误：<code>func canThrowErrors() throws -&gt; String</code></li><li>用<code>throw</code>抛出错误：<code>throw VendingMachineError.OutOfStock</code></li><li>调用抛出错误的函数时，前面加上<code>try</code>：<code>try canThrowErrors()</code></li><li>用do-catch捕获错误：  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">try</span> <span class="title">canThrowErrors</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125; <span class="keyword">catch</span> someError</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>swift的错误和其他语言的异常类似，但是不会展开调用堆栈，因此throw语句的性能可以几乎和return语句一样</li><li>如果确认某个声明了throws的函数不会抛出错误，可以用<code>try!</code>禁止错误传播：<code>try! willOnlyThrowIfTrue(false)</code></li><li>用<code>defer</code>语句将操作压栈，推迟到当前作用域结束时执行</li></ul><h3 id="Type-Casting"><a href="#Type-Casting" class="headerlink" title="Type Casting"></a>Type Casting</h3><ul><li>类型检查用<code>is</code>，强制类型转换用<code>as</code>，如<code>let view = object as UIView</code>，尝试类型转换用<code>as?</code>，如<code>if let view = object as? UIView { ... }</code></li><li>可以转换整个数组：<code>if let viewArray = objectArray as? [UIView] { ... }</code>，有任一元素转换失败时整个返回nil</li><li><code>AnyObject</code>表示任何class类型，<code>Any</code>表示任何类型</li></ul><h3 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h3><ul><li>可以添加新的方法，但不能重写已有的方法</li><li>可以添加计算型属性，但不能添加存储型属性，也不能给已有属性添加属性观测器（willSet/didSet等）</li><li>可以添加convenience构造器，但不能添加designated构造器或析构器</li></ul><h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><ul><li>如果协议的方法将改变遵循该协议的对象的属性，则在该方法前加<code>mutating</code>关键字（为了使struct/enum等值类型也能遵循该协议）</li><li>协议可以继承一个或多个其他协议：<code>protocol SomeProtocol: InheritedProtocolOne, InheritedProtocolTwo {}</code></li><li>限制只能由class遵循该协议（struct/enum不能遵循该协议），要在继承列表开头使用<code>class</code>关键字：<code>protocol SomeClassOnlyProtocol: class, InheritedProtocol {}</code></li><li>变量遵循了多个协议：<code>person: protocol&lt;Named, Aged&gt;</code></li><li>能用<code>is/as/as?</code>检查变量是否遵循协议</li><li>协议包含可选方法或属性时，要加<code>@objc</code>前缀：  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">CounterDataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">incrementForCount</span><span class="params">(<span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">var</span> fixedIncrement: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可通过Extension为协议提供默认实现，扩展协议时还能用<code>where</code>描述限制条件：  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> CollectionType where Generator.<span class="built_in">Element</span> : TextRepresentable &#123;</span><br><span class="line">    <span class="comment">// 扩展CollectionType协议，但只适用于元素遵循TextRepresentable的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以用<code>typealias</code>声明关联类型，给类型提供占位名，当某类实现这协议时能自动推断出实际的关联类型  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: ItemType)</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><ul><li>泛型，形如<code>struct Stack&lt;T&gt; { ... }</code></li><li>扩展泛型时，不需要在扩展的定义中再次声明类型参数，原类型参数可以直接使用：  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">T?</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>泛型的类型参数可以添加约束，如：  <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">func</span> allItemsMatch&lt;<span class="built_in">C1</span>: Container, <span class="built_in">C2</span>: Container</span><br><span class="line">        where <span class="built_in">C1</span>.<span class="keyword">ItemType </span>== <span class="built_in">C2</span>.<span class="keyword">ItemType, </span><span class="built_in">C1</span>.<span class="keyword">ItemType: </span>Equatable&gt;</span><br><span class="line">        (someContainer: <span class="built_in">C1</span>, anotherContainer: <span class="built_in">C2</span>) -&gt; <span class="keyword">Bool </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h3><ul><li><code>private</code>源文件内可见；<code>internal</code>模块内可见，是默认值，模块指以独立单元构建和发布的framework或application；<code>public</code>都可见</li><li>函数的访问级别由参数和返回值中最小的一个决定</li></ul><h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><ul><li>算数运算符默认不会溢出，溢出运算符有：<code>&amp;+</code>、<code>&amp;-</code>、<code>&amp;*</code>等</li><li>重载运算符，如：  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2D</span> </span>&#123; <span class="keyword">var</span> x = <span class="number">0.0</span>,, y = <span class="number">0.0</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> +<span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123; &#125; <span class="comment">// 中缀</span></span><br><span class="line"><span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> -<span class="params">(vector: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;&#125; <span class="comment">// 前缀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> += <span class="params">(<span class="keyword">inout</span> <span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> &#123; <span class="keyword">left</span> = <span class="keyword">left</span> + <span class="keyword">right</span> &#125; <span class="comment">// 组合赋值</span></span><br></pre></td></tr></table></figure></li><li>自定义操作符可声明优先级和结合性：  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> +- &#123; <span class="keyword">associativity</span> <span class="keyword">left</span> <span class="keyword">precedence</span> <span class="number">140</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> +- <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Command-Line"><a href="#Command-Line" class="headerlink" title="Command Line"></a>Command Line</h3><ul><li>demangle: <code>xcrun swift-demangle</code> xxx</li></ul><h3 id="Using-with-Cocoa-amp-ObjC"><a href="#Using-with-Cocoa-amp-ObjC" class="headerlink" title="Using with Cocoa &amp; ObjC"></a>Using with Cocoa &amp; ObjC</h3><ul><li>在.m文件中使用swift：<code>#import &quot;ProductModuleName-Swift.h&quot;</code></li><li>在.swift文件中使用objc：把要使用的objc头文件加入<code>ProductModuleName-Bridging-Header.h</code>中，之后所有.swift文件中不需要import就能使用</li><li>从objc类继承的swift类会由编译器自动插入<code>@objc</code>，因而在objc中可用</li><li>不从objc类继承的swift类要在objc中可用，需要自己添加<code>@objc</code>标注</li><li>用<code>@objc(&lt;#name#&gt;)</code>可以给swift类/方法起objc别名（不带名称空间）</li><li>swift闭包和objc闭包互通，swift闭包中的变量类似objc闭包中的<code>__block</code>变量</li><li><code>@NSManaged</code>就像<code>@dynamic</code>，表示<code>NSManagedObject</code>子类属性的存储和实现将在运行时提供</li></ul><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><ul><li>struct按值顺序排，会字节对齐</li><li>swift类都继承自SwiftObject，SwiftObject实现了<NSObject>协议，但不是NSObject的子类</li><li>SwiftObject前两个8字节分别是isa和refCount (swift中的NSObject类空着这后8字节refCount不用)</li><li>swift中的NSObject布局：isa, superclass, cache, …, 构成vtable的各方法指针</li><li>class的optional，跟指针一样，指向地址或nil；struct的optional多加1字节表示值是否nil</li><li>protocol共占40字节；class的protocol布局为：isa, 空着不用16字节, 指向底层类的metadata的指针，指向实现protocol的vtable的指针；struct的protocol布局为：24字节内inline存储值（超过24字节保存malloc的地址8字节, 空着不用16字节），指向底层类的metadata的指针，指向实现protocol的vtable的指针</li></ul><h3 id="Playground和-swift文件"><a href="#Playground和-swift文件" class="headerlink" title="Playground和.swift文件"></a>Playground和.swift文件</h3><ul><li><code>main.swift</code>和playground一样都是order-dependent的，且允许顶层代码</li><li>iOS里加<code>@UIApplicationMain</code>的那个文件就相当于<code>main.swift</code></li><li>其他swift文件都是order-independent的，且不允许顶层代码</li></ul><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank" rel="noopener">《The Swift Programming Language》</a></li><li>《Using Swift with Cocoa and Objective-C》</li><li>Intermediate Swift, WWDC2014</li><li>Exploring Swift Memory Layout <a href="https://www.mikeash.com/pyblog/friday-qa-2014-07-18-exploring-swift-memory-layout.html" target="_blank" rel="noopener">part I</a> &amp; <a href="https://www.mikeash.com/pyblog/friday-qa-2014-08-01-exploring-swift-memory-layout-part-ii.html" target="_blank" rel="noopener">part II</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;code&gt;let&lt;/code&gt;声明常量，&lt;code&gt;var&lt;/code&gt;声明变量&lt;/li&gt;
&lt;li&gt;注释：&lt;code&gt;//&lt;/code&gt;和&lt;code&gt;/*...*/&lt;/code&gt;，多行注释&lt;code&gt;/*...*/&lt;/code&gt;可嵌套！&lt;/li&gt;
&lt;li&gt;句尾
      
    
    </summary>
    
    
    
      <category term="lang" scheme="http://note.49px.com/tags/lang/"/>
    
  </entry>
  
  <entry>
    <title>Javascript ES6 笔记</title>
    <link href="http://note.49px.com/es6/"/>
    <id>http://note.49px.com/es6/</id>
    <published>2015-10-07T16:00:00.000Z</published>
    <updated>2015-10-08T13:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><p>for-of通过迭代器遍历各种集合，for-in遍历对象属性</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>对象通过<code>[Symbol.iterator]()</code>方法指定它的迭代器，迭代器是实现了.next()方法的对象，.next()方法的返回值形如<code>{done: false, value: xxx}</code></p><p>迭代器贯穿ES6的始终，它是数据和循环的新标准。</p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器函数用<code>function*</code>声明。生成器函数内部的yield类似return，区别是只能return一次却可以yield多次。生成器执行时遇到yield就暂停，后续可恢复执行状态。</p><p>当你调用生成器函数时，它并不立即执行，而是返回一个暂停在函数入口的迭代器。当你调用迭代器的.next()方法时，函数恢复执行，直到下一个yield后再暂停。</p><p>.next()方法接受一个可选参数，该参数在稍后函数恢复执行时会代替yield表达式的返回值</p><p>生成器是迭代器。所有的生成器都有内建<code>[Symbol.iterator]()</code>和.next()方法的实现。你只须编写循环部分的行为。</p><p>使对象可遍历：通过<code>[Symbol.iterator]()</code>方法指定对象的迭代器为生成器函数，编写这个生成器函数来yield这个对象的每一个值。</p><p>当你面对一个复杂的循环时，你可以拆分出生成数据的代码，将其转换为独立的生成器函数，然后使用<code>for (let data of myNewGenerator(args))</code>遍历我们所需的数据。</p><p>yield只能生成一个值；<code>yield*</code>可以后接迭代器，一次次直到遍历该迭代器的所有值</p><p>可用<code>yield*</code>在生成器中调用生成器</p><h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>模板用 `（反撇号）括起来，字符串插值形如<code>${user.name}</code></p><p>标签模板，在模板字符串开始的反撇号前加一个额外的标签</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;bonk.sender&#125;</span> 向你示好。&lt;/p&gt;`</span>;</span><br></pre></td></tr></table></figure><p>上面代码等效于</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var message = <span class="constructor">SaferHTML(<span class="params">templateData</span>, <span class="params">bonk</span>.<span class="params">sender</span>)</span>;</span><br></pre></td></tr></table></figure><p>templateData是一个不可变数组，存储着模板所有的字符串部分。</p><h3 id="不定参数和默认参数"><a href="#不定参数和默认参数" class="headerlink" title="不定参数和默认参数"></a>不定参数和默认参数</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsAll</span><span class="params">(haystack, <span class="rest_arg">...needles</span>)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> animal<span class="constructor">Sentence(<span class="params">animals2</span>=<span class="string">"tigers"</span>, <span class="params">animals3</span>=<span class="string">"bears"</span>)</span></span><br></pre></td></tr></table></figure><p>默认值表达式自左向右求值，这意味着，后面的赋值式可以使用前面的刚赋了值的参数</p><p>没有默认值的参数隐式默认为undefined</p><p>传递undefined值等效于不传值</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">variable</span><span class="number">1</span>, <span class="keyword">variable</span><span class="number">2</span>, ..., variableN ] = array;</span><br></pre></td></tr></table></figure><p>如果你想在赋值的同时声明变量，可在赋值语句前加入var、let或const关键字，如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [foo, <span class="string">[[bar], baz]]</span> = [<span class="number">1</span>, <span class="string">[[2], 3]]</span>;</span><br></pre></td></tr></table></figure><p>可以在对应位留空来跳过被解构数组中的某些元素：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> [,,<span class="built_in">third</span>] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br></pre></td></tr></table></figure><p>可以通过“不定参数”模式捕获数组中的所有尾随元素：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">log</span>(<span class="params">...array</span>)</span>; <span class="comment">// log所有值</span></span><br></pre></td></tr></table></figure><p>当访问空数组或越界访问数组时，对其解构与对其索引的结果都是：undefined</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta"></span>][<span class="number">0</span>] <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> [missing] = []; <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>数组解构赋值的模式同样适用于任意迭代器：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123; … &#125;</span><br><span class="line"><span class="keyword">var</span>[first,second,third] = fibs();</span><br></pre></td></tr></table></figure><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><p>首先指定属性，然后指定变量：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span>&#123;<span class="built_in">na</span><span class="symbol">me:na</span>meA&#125;=&#123;<span class="built_in">na</span><span class="symbol">me:</span><span class="string">"Bender"</span>&#125;; // nameA</span><br></pre></td></tr></table></figure><p>当属性名与变量名一致时可简写：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">var</span> &#123; foo, <span class="keyword">bar </span>&#125; = &#123; foo: <span class="string">"lorem"</span>, <span class="keyword">bar: </span><span class="string">"ipsum"</span> &#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>解构对象时若赋值语句前没有let、const或var关键字，要将整个表达式用一对小括号包裹（防止js引擎将任何以<code>{</code>开始的语句解析为块语句）：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123; blowUp &#125; = &#123; blowUp: <span class="number">10</span> &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>当你要解构的属性未定义时你可以提供一个默认值：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [missing = <span class="literal">true</span>] = [];</span><br><span class="line"><span class="keyword">var</span> &#123; message: msg = <span class="string">"Something went wrong"</span> &#125; = &#123;&#125;; <span class="comment">// msg</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>只有一个参数时，形如：<code>arg =&gt; expr</code></p><p>多个参数（或无参数、不定参数、默认参数、参数解构）时，要用小括号包裹参数：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = values.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>返回的对象字面量要包裹在小括号里：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chewToys = puppies.map(<span class="function"><span class="params">puppy</span> =&gt;</span> (&#123;&#125;));</span><br></pre></td></tr></table></figure><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isMoving = <span class="constructor">Symbol(“<span class="params">the</span> <span class="params">description</span><span class="string">");</span></span></span><br></pre></td></tr></table></figure><p>symbol不能被自动转换为字符串，要通过<code>String(sym)</code>或<code>sym.toString()</code>显式转换</p><p>获取symbol：</p><ul><li>Symbol() // 新建symbol</li><li>Symbol.for(key) // 共享symbol</li><li>少许几个自带的symbol，如<code>Symbol.iterator</code></li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Map或Set的遍历顺序就是其中元素的插入顺序</p><p>WeakMap或WeakSet都不可遍历</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>有形如<code>obj.[[xxx]]()</code>的14个内部方法</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var<span class="built_in"> proxy </span>= new Proxy(target, handler)</span><br></pre></td></tr></table></figure><p>handler对象所含的方法将对应重写proxy的内部方法，没被重写的proxy方法调用会转发到target上执行</p><h3 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h3><p>let就是新的var，块级作用域，for循环的每次迭代绑定新的let变量（不像原来的所有迭代都绑定同一个var变量）</p><p>const声明常量</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>一个文件就是一个模块</p><p>导出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> &#123;detectCats, Kittydar&#125;;</span><br><span class="line"><span class="builtin-name">export</span>  &#123; v1 as streamV1, v2 as streamV2 &#125;;</span><br><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>&#123; field1: value1, field2: value2 &#125;;</span><br><span class="line"><span class="builtin-name">export</span> &#123;Tea, Cinnamon&#125; <span class="keyword">from</span> <span class="string">"sri-lanka"</span>;</span><br></pre></td></tr></table></figure><p>或直接在function、class、let/const/var的声明前加<code>export</code>关键字</p><p>导入：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;detectCats, Kittydar&#125; <span class="keyword">from</span> <span class="string">"kittydar.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;flip <span class="keyword">as</span> flipOmelet&#125; <span class="keyword">from</span> <span class="string">"eggs.js"</span>;</span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"lodash"</span>; <span class="comment">// 导入default</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> cows <span class="keyword">from</span> “cows”;</span><br></pre></td></tr></table></figure><h3 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h3><p>Async函数和生成器类似，但特定于异步编程。调用generator返回iterator，调用async函数则返回promise。generator使用yield来暂停并生成值，async函数则使用await来暂停并等着promise。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.infoq.com/cn/es6-in-depth/" target="_blank" rel="noopener">深入浅出ES6 [译]</a>（<a href="https://hacks.mozilla.org/category/es6-in-depth/" target="_blank" rel="noopener">原文</a>）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;for-of&quot;&gt;&lt;a href=&quot;#for-of&quot; class=&quot;headerlink&quot; title=&quot;for-of&quot;&gt;&lt;/a&gt;for-of&lt;/h3&gt;&lt;p&gt;for-of通过迭代器遍历各种集合，for-in遍历对象属性&lt;/p&gt;
&lt;h3 id=&quot;迭代器&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="lang" scheme="http://note.49px.com/tags/lang/"/>
    
  </entry>
  
  <entry>
    <title>构建高性能Web站点</title>
    <link href="http://note.49px.com/web/"/>
    <id>http://note.49px.com/web/</id>
    <published>2015-10-05T16:00:00.000Z</published>
    <updated>2015-10-08T15:46:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统基础"><a href="#系统基础" class="headerlink" title="系统基础"></a>系统基础</h3><p>吞吐率（qps, request per second）量化描述了服务器的并发处理能力</p><p>压力测试的前提条件：</p><ul><li>并发用户数</li><li>总请求数</li><li>请求资源描述（静态/动态）</li></ul><p>数据链路层的流量控制是通过控制接收方来实现的</p><p>支持400MHz前端总线频率的32位处理器，理论上它的总线带宽为：<br>32bit*400MHz = 12.8Gbps = 1.6GB/s</p><p>进程优先级（top命令中的PR）表示进程调度器分配给进程的时间片个数。一个时间片的长度跟CPU的主频和操作系统有关，比如Linux上一般为10ms，那么PR值为15表示这个进程的时间片为150ms。</p><p>Linux对进程的动态调整，体现在进程的nice属性中（top命令中的NI）</p><p>内核级线程一一对应着轻量级进程，所以也有上下文切换开销</p><p>系统负载（top命令中LoadAvg）表示运行队列中就绪态的进程数平均值，<br>top中显示的是最近1分钟、5分钟、15分钟分别计算的系统负载</p><p>进程有独立的内存空间，但只能共享CPU寄存器。进程被挂起的本质是将它在CPU寄存器中的数据拿出来暂存在内核态堆栈中，而恢复工作的本质是将它的数据重新装入CPU寄存器。这段装入装出的数据被称为“硬件上下文”，它是进程上下文的一部分。除此之外，进程上下文还包含进程运行时需要的一切状态信息。</p><p>top的RES值表示其占用的物理内存大小，SWAP值表示其使用的虚拟内存大小，VIRT值等于RES和SWAP的总和，默认单位是KB。</p><p>IOWait指CPU空闲等待IO的时间比例，描述了CPU的性能。CPU可能因为IO在wait，也可能因为频繁切换进程等其他原因在wait，所以IOWait不能代表IO操作的性能。要真正了解当前IO，可以进行磁盘IO测试或查看网络IO流量等。</p><p>同步非阻塞IO：轮询</p><p>多路IO就绪通知</p><ul><li>select/poll：本质上没多大差别，告知所有就绪的文件描述符（level triggered，水平触发），轮询</li><li>sigio：告知刚刚变为就绪状态的文件描述符（edge triggered，边缘触发），轮询</li><li>epoll：支持水平触发和边缘触发，事件通知</li></ul><p>内存映射：将内存中某块地址空间和指定的磁盘文件相关联，从而把对这块内存的访问转换为对磁盘文件的访问<br>在大多数情况下，使用内存映射可以提高磁盘IO的性能，它无须使用read()或write()等系统调用来访问文件，而是通过mmap()系统调用来建立内存和磁盘文件的关联，然后像访问内存一样访问文件。<br>内存映射和直接访问文件没有本质上差别，因为数据从磁盘到用户态内存都要经过两次复制：磁盘&lt;-&gt;内核缓冲区，内核缓冲区&lt;-&gt;用户态内存。</p><p>sendfile()系统调用：处理静态文件请求时，磁盘文件的数据先经过内核缓冲区，到达用户内存空间；因为是不需要任何处理的静态数据，所以它们又被送到网卡对应的内核缓冲区，然后再被送入网卡进行发送。sendfile()系统调用可以将磁盘文件的特定部分直接传送到客户端的socket描述符，加快静态大文件的请求速度</p><hr><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>询问服务器本地缓存是否可用（缓存协商）</p><ul><li>Last-Modified 和 If-Modified-Since</li><li>ETag 和 If-None-Match</li></ul><p>使用Last-Modified存在一些缺点，比如，每次文件的修改时间变化后，无论内容是否真的变化，浏览器都会重新获取全部内容；再比如，同一个文件存储在多台Web服务器上，用户的请求在这些服务器之间轮询，实现负载均衡，而这些服务器上同一个文件的最后修改时间很难保证完全相同，这会导致用户的请求每次切换到新的服务器时就需要重新获取全部内容。这时候，使用直接标记内容的某种ETag算法，就可以避免这些问题。</p><p>直接使用本地缓存</p><ul><li>Expires 和 Cache-Control</li></ul><p>Expires使用绝对时间，若客户端和服务端的时间不一致，本地缓存的有效期检查就有问题。Cache-Control使用max-age这一相对时间弥补了Expires的不足。当响应头中同时含有Expires和Cache-Control时，浏览器优先使用Cache-Control。</p><p>要更新静态文件的缓存，在引用文件时让url发生变化即可，比如增加一些个性化的参数：the-static-file-url?v=1.2</p><p>长连接：客户端在发出的http请求头中包含<code>Connection: Keep-Alive</code>，服务端一般默认支持长连接。当客户端和服务端对长连接的超时设置不一致时，以较短的超时时间为准</p><p>gzip压缩：请求头里面可用<code>Accept-Encoding</code>告知浏览器支持的压缩方式，而服务端则用<code>Content-Encoding</code>作为回应</p><p>浏览器三种刷新方式：</p><ul><li>Ctrl+F5或Ctrl+刷新按钮：强制刷新，缓存都无效</li><li>F5或刷新按钮：一般刷新，缓存协商有效（Last-Modified有效），但本地缓存无效（Expires无效）</li><li>点击超链接或地址栏输入后跳转：以最少请求来获取网页，会对所有没过期内容直接使用本地缓存（Expires只对这种方式有效）</li></ul><p>浏览器对同一域名有最大并发数限制。为了增加并发，尤其是对一些静态资源，可以使用多个域名。但由于域名解析本身也耗时，所以实践上2-4个为宜。需要注意是，加载js脚本时会暂停加载其他资源。</p><p>当我们扩展缓存系统的服务器数后，由于分区算法的改变，重建和预热缓存需要时间，但我们不需要考虑缓存数据在分区之间的迁移，因为这是缓存，不影响站点的正常运转。</p><hr><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>在select语句前加<code>explain</code>，可以看查询过程是否使用了索引</p><p>一次查询只能使用一个索引，多个索引无法共同使用，所以有时要创建组合索引</p><p>索引对where / order by / group by子句中使用的字段都可起作用，若查询子句只包含组合索引的最左前缀（创建组合索引时的多个key中最左的几个key），则查询会直接使用这个组合索引</p><p>mysql可以开启慢查询日志，和未使用索引查询的日志</p><p>大多数的慢查询都是因为索引使用不当，其他原因包括查询语句过于复杂（比如联合查询）或者数据表记录数过多，通过反范式化设计（引入冗余数据）和数据分区可以有效改善这一状况。</p><p>mysql可以开启查询缓存。缓存过期策略是：当一个数据表有更新操作后（如update或insert），涉及这个表的所有查询缓存都失效。</p><p>mysql可以开启线程池</p><p>两种数据库格式：</p><ul><li>MyISAM：表锁定</li><li>Innodb：行锁定、事务（预写日志）</li></ul><p>简单地说，3NF（第三范式）要求在一个数据表中，非主键字段之间不存在依赖关系</p><hr><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>http重定向：使用http响应头的Location域</li><li>DNS负载均衡</li><li>反向代理负载均衡</li><li>NAT</li><li>直接路由</li><li>IP隧道</li></ul><p>后端怎么保存session：</p><ul><li>本地化保存，要对ip做hash或用cookie记后端服务器编号</li><li>分布式session服务器</li></ul><p>NAT，内核态转发</p><ul><li>Netfilter/iptables。Netfilter在内核中维护着一些数据包过滤表，iptables这命令行工具可以对Netfilter的过滤表进行插入、修改或删除操作</li><li>IPVS/ipvsadm。ipvsadm比iptables用起来更方便</li></ul><p>当实际服务器的吞吐率小于3000qps时，反向代理和NAT负载均衡的整体吞吐率差距不大。这意味着对于一些开销较大的内容，使用简单的反向代理来搭建负载均衡系统非常值得考虑，至少在初期是个快速有效的方案，而且它非常容易迁移到NAT方式。</p><p>将基于NAT的集群和DNS轮询混合使用，你可以组建多个条件允许的NAT集群，比如5个100Mbps出口带宽的集群，然后通过DNS轮询方式来将用户请求均衡地指向这些集群，同时你还可以利用DNS智能解析实现地域就近访问。</p><p>直接路由（也使用ipvsadm）：<br>工作在数据链路层（第二层），调度器通过修改数据包的目标MAC地址，将它转发到实际服务器。实际服务器要添加和调度器相同的IP别名，设置不寻找其他拥有这个IP别名的服务器，不响应网络中针对这个IP别名的ARP广播，这样才可以让转发到实际服务器的数据包找到归属。</p><p>IP别名：一个网络接口除了拥有一个IP地址，最多还可以为它设置256个IP别名</p><p>直接路由比起NAT转发的优势在于，实际服务器的响应数据包不经过调度器而直接发往用户端（实际服务器要直接接入外部网络）</p><p>RFC1918规定的私有IP地址范围是：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span>      -   <span class="number">10.255</span><span class="number">.255</span><span class="number">.255</span>     (<span class="number">10</span>/<span class="number">8</span> prefix)</span><br><span class="line"><span class="number">172.16</span><span class="number">.0</span><span class="number">.0</span>    -   <span class="number">172.31</span><span class="number">.255</span><span class="number">.255</span>     (<span class="number">172.16</span>/<span class="number">12</span> prefix)</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>   -   <span class="number">192.168</span><span class="number">.255</span><span class="number">.255</span>    (<span class="number">192.168</span>/<span class="number">16</span> prefix)</span><br></pre></td></tr></table></figure><p>IP隧道：<br>与直接路由类似，但实际服务器和调度器可以不在同一个WAN网段，将调度器收到的IP数据包封装在新数据包中转发给实际服务器，然后实际服务器的响应数据包可以直接发往用户端。</p><hr><h3 id="扩展数据库"><a href="#扩展数据库" class="headerlink" title="扩展数据库"></a>扩展数据库</h3><p>主从复制（主服务器开启日志，写操作只能在主服务器）、读写分离（MySQL Proxy，数据库反向代理）</p><p>垂直分区：将不需要联合使用的数据库表分布到不同的服务器</p><p>水平分区：将同一数据表中的记录通过特定算法分离成不同的数据表，从而可以部署到不同的服务器</p><p>事实上，很多大规模的站点基本上都经历了从简单主从复制到垂直分区，再到水平分区的过程</p><p>分区算法：</p><ul><li>按哈希分：按照分区索引字段的哈希做分区，对分区扩展并不友好，一旦我们需要从10个分区扩展到20个分区，这便涉及所有数据的重新分区</li><li>按范围分：按照分区索引字段的范围做分区，较好扩展，但各个分区的工作量会存在较大差异</li><li>维持映射关系：维持每个记录的分区对应关系，可能十分庞大</li></ul><p>分布式的并行计算：Map/Reduce</p><hr><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>用apache附带的<code>ab</code>做压力测试</p><p>用Nmon可以监视服务器每秒上下文切换次数</p><p>反向代理缓存服务器：Squid太古老笨重，可用Varnish</p><p>用mysqlsla查看mysql慢查询日志</p><p>Spock Proxy，mysql多个水平分区的访问调度</p><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>《构建高性能Web站点》，郭欣，2009</li><li><a href="http://www.2liang.me/archives/264" target="_blank" rel="noopener">构建高性能WEB之HTTP首部优化</a></li><li><a href="http://segmentfault.com/a/1190000003821219" target="_blank" rel="noopener">前端性能优化方案索引</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;系统基础&quot;&gt;&lt;a href=&quot;#系统基础&quot; class=&quot;headerlink&quot; title=&quot;系统基础&quot;&gt;&lt;/a&gt;系统基础&lt;/h3&gt;&lt;p&gt;吞吐率（qps, request per second）量化描述了服务器的并发处理能力&lt;/p&gt;
&lt;p&gt;压力测试的前提条件：&lt;
      
    
    </summary>
    
    
    
      <category term="web" scheme="http://note.49px.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Debug笔记</title>
    <link href="http://note.49px.com/debug/"/>
    <id>http://note.49px.com/debug/</id>
    <published>2014-12-11T16:00:00.000Z</published>
    <updated>2015-10-01T08:35:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="错误预防"><a href="#错误预防" class="headerlink" title="错误预防"></a>错误预防</h3><p>断言：</p><ul><li>NSParameterAssert/NSAssert用于ObjC函数，NSCParameterAssert/NSCAssert用于C函数</li><li>ObjC函数中<code>NSParameterAssert</code>用在开头检查输入参数，其他情况都用<code>NSAssert</code></li><li>不用<code>assert</code>，因为它只终止程序不输出信息</li></ul><p>参数非nil的编译检查：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>doSomethingWithRequiredString:<span class="params">(NSString *)</span>requiredString </span><br><span class="line">                                  bar:<span class="params">(NSString *)</span>optionalString </span><br><span class="line">                                  __attribute<span class="params">((nonnull(<span class="number">1</span>))</span>);</span><br></pre></td></tr></table></figure><h3 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h3><p><code>e</code>（即<code>expression</code>）对表达式求值，是lldb最基本的命令</p><p><code>p</code>（即<code>print</code>）是<code>expression --</code>的简写，<code>po</code>是<code>expression -O --</code>的简写</p><p><code>p/&lt;format&gt;</code>可以指定print的<a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html" target="_blank" rel="noopener">输出格式</a>，如：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x <span class="number">16</span>            // <span class="number">0x10</span></span><br><span class="line">(lldb) p/t (char)<span class="number">16</span>      // <span class="number">0b00010000</span>，t stands <span class="keyword">for</span> two</span><br></pre></td></tr></table></figure><p>lldb可以声明变量名以<code>$</code>开始的变量：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) e <span class="built_in">int</span> $a = <span class="number">2</span></span><br><span class="line">(lldb) p $a * <span class="number">19</span>         <span class="comment">// 38</span></span><br></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="keyword">e</span> NSArray *<span class="variable">$array</span> = @[ @<span class="string">"Sunday"</span>, @<span class="string">"Monday"</span> ]</span><br><span class="line">(lldb) p [<span class="variable">$array</span> <span class="keyword">count</span>]  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>若lldb不清楚返回值的类型，需要明确指定：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (char)[[$<span class="built_in">array</span> objectAtIndex:<span class="number">0</span>] characterAtIndex:<span class="number">0</span>]    <span class="comment">// 'S'</span></span><br></pre></td></tr></table></figure><p>或者导入框架，然后就不需指定返回值类型：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) expr @import UIKit</span><br><span class="line">(lldb) <span class="selector-tag">p</span> slef<span class="selector-class">.window</span>.bounds</span><br></pre></td></tr></table></figure><p>为方便起见，可在~/.lldbinit中添加：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">command</span> <span class="keyword">alias</span> uikit expr @<span class="keyword">import</span> UIKit</span><br></pre></td></tr></table></figure><p><code>c</code>/<code>n</code>/<code>s</code>/<code>fin</code>（即continue / next / step / finish）分别对应Continue、Step Over、Step Into、Step Out</p><p><code>frame info</code>可以查看当前函数调用帧</p><p><code>thread return [value]</code>可以让函数直接return或return某个值</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>查看window的hierarchy（pviews）：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">po <span class="comment">[<span class="comment">[UIWindow keyWindow]</span> recursiveDescription]</span></span><br></pre></td></tr></table></figure><p>查看viewController的hierarchy（pvc）：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">po <span class="comment">[<span class="comment">[<span class="comment">[UIWindow keyWindow]</span> rootViewController]</span> _printHierarchy]</span> // _printHierarchy是iOS8里的私有方法</span><br></pre></td></tr></table></figure><p>更改视图属性后刷新界面（caflush）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e (<span class="keyword">void</span>)[CATransaction <span class="built_in">flush</span>]</span><br></pre></td></tr></table></figure><p>先找到某button的target：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [<span class="variable">$myButton</span> <span class="literal">all</span>Targets]</span><br><span class="line">&#123;(</span><br><span class="line">    <span class="variable">&lt;MagicEventListener: 0x7fb58bd2e240&gt;</span></span><br><span class="line">)&#125;</span><br><span class="line">(lldb) po [<span class="variable">$myButton</span> actionsForTarget:(id)<span class="number">0</span>x7fb58bd2e240 <span class="keyword">for</span>ControlEvent:<span class="number">0</span>]</span><br><span class="line"><span class="variable">&lt;__NSArrayM 0x7fb58bd2aa40&gt;</span>(</span><br><span class="line">_handleTap:</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后在<code>-[MyEventListener _handleTap:]</code>上设置符号断点</p><h3 id="Chisel"><a href="#Chisel" class="headerlink" title="Chisel"></a>Chisel</h3><p>LLDB内置支持python，通过<code>script</code>命令可调用python代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb)<span class="built_in"> script </span>import os</span><br><span class="line">(lldb)<span class="built_in"> script </span>os.system(<span class="string">"open http://www.objc.io/"</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/facebook/chisel" target="_blank" rel="noopener">Chisel</a>就是通过<code>~/.lldbinit</code>加载的便利iOS调试的python脚本集合：</p><ul><li><p>查看window的hierarchy：<code>pviews</code></p></li><li><p>查看viewController的hierarchy：<code>pvc</code></p></li><li><p>查看responder链：<code>presponder</code></p></li><li><p>更改视图属性后刷新界面：<code>caflush</code></p></li><li><p>显示/隐藏视图：<code>show</code>/<code>hide</code></p></li><li><p>监视ivar变化：<code>wiar</code></p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) wivar <span class="symbol">$my</span>View _layer</span><br></pre></td></tr></table></figure></li><li><p>在message上设置断点：<code>bmessage</code></p>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">lldb) </span><span class="keyword">bmessage </span>-[MyViewController viewDidAppear:]</span><br></pre></td></tr></table></figure></li></ul><h3 id="Aspects"><a href="#Aspects" class="headerlink" title="Aspects"></a>Aspects</h3><p>用<a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Aspects</a>可以hook进方法打印log：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">UIViewController</span> aspect_hookSelector:@selector(<span class="name">viewWillAppear:</span>) withOptions:AspectPositionAfter usingBlock:^(<span class="name">id&lt;AspectInfo&gt;</span> aspectInfo, BOOL animated) &#123;</span><br><span class="line">    NSLog(<span class="name">@</span><span class="string">"View Controller %@ will appear animated: %tu"</span>, aspectInfo.instance, animated)<span class="comment">;</span></span><br><span class="line">&#125; error:NULL]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其中block的第一个参数是<code>id&lt;AspectInfo&gt;</code>，其他参数（可选）就是被hook方法的参数列表</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="http://www.objc.io/issue-19/debugging-case-study.html" target="_blank" rel="noopener">Debugging: A Case Study</a></li><li><a href="http://www.objc.io/issue-19/lldb-debugging.html" target="_blank" rel="noopener">Dancing in the Debugger — A Waltz with LLDB</a></li><li><a href="http://furbo.org/2015/05/11/an-import-ant-change-in-xcode/" target="_blank" rel="noopener">An @import-ant Change in Xcode</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;错误预防&quot;&gt;&lt;a href=&quot;#错误预防&quot; class=&quot;headerlink&quot; title=&quot;错误预防&quot;&gt;&lt;/a&gt;错误预防&lt;/h3&gt;&lt;p&gt;断言：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSParameterAssert/NSAssert用于ObjC函数，NSCParamet
      
    
    </summary>
    
    
    
      <category term="ios" scheme="http://note.49px.com/tags/ios/"/>
    
  </entry>
  
</feed>
